{"version":3,"file":"cube.esm.min.js","sources":["../src/errors.js","../src/console.js","../src/Fact.js","../src/Cell.js","../src/EmptyCell.js","../src/Member.js","../src/const.js","../src/InputMember.js","../src/DimensionTable.js","../src/Tree.js","../src/DimensionTree.js","../src/DimensionHierarchy.js","../src/FactTable.js","../src/SnowflakeBuilder.js","../src/Tuple.js","../src/Space.js","../src/Cube.js"],"sourcesContent":["export class InsufficientRollupData {\n\tconstructor(dimension, id) {\n\t\tthis.message = `Can't add member, member for rollup dimension: ${dimension} with id: ${id} not found`;\n\t}\n}\n\nexport class NotFoundFactId {\n\tconstructor(name) {\n\t\tthis.message = `In fact data, no property was found with the name: ${name}`\n\t}\n}\n\nexport class NotCompletelySpaceException {\n\tconstructor(dimension) {\n\t\tthis.message = `Not completely defined space for added member, not found member for dimension: \"${dimension}\"`;\n\t}\n}\n\nexport class CantAddMemberRollupException {\n\tconstructor(dimension, id) {\n\t\tthis.message = `Can't add member, rollup dimension: ${dimension} with id: ${id} not found`;\n\t}\n}\n\nexport class CreateInstanceException {\n\tconstructor() {\n\t\tthis.message = 'this must have prototype of Cube'\n\t}\n}\n\nexport class DimensionException {\n\tconstructor(dimension) {\n\t\tthis.message = `For the name \"${dimension}\" the dimension is already set`;\n\t}\n}\n\nexport const handleError = error => {\n\terror.message = `[Cube] ${error.message}`\n\tthrow error;\n};\n","const originalConsole = console;\nconst customConsole = {\n\tlog: string => {\n\t\toriginalConsole.log(`[Cube] ${string}`)\n\t},\n\twarn: string => {\n\t\toriginalConsole.warn(`[Cube] ${string}`)\n\t},\n\twarnOnce: (() => {\n\t\tconst memory = {};\n\t\treturn string => {\n\t\t\tif (!memory[string]) {\n\t\t\t\tmemory[string] = true;\n\t\t\t\toriginalConsole.warn(`[Cube] ${string}`)\n\t\t\t}\n\t\t};\n\t})()\n};\nexport default customConsole\n","import {handleError} from './errors.js'\nimport console from './console.js'\n\nconst isSimple = (value) => {\n\tlet type = typeof value;\n\treturn type !== 'object' && type !== 'function' && type !== 'undefined' || value === null\n};\n\nexport default class Fact {\n\t/**\n\t * @throw {NotFoundFactId}\n\t * */\n\tconstructor(data) {\n\t\ttry {\n\t\t\tfor (let key in data) {\n\t\t\t\tif (!data.hasOwnProperty(key)) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tif (isSimple(data[key])) {\n\t\t\t\t\tthis[key] = data[key];\n\t\t\t\t} else {\n\t\t\t\t\tconsole.warn(`[Fact] value of prop \"${key}\" has an unspecified value: ${data[key]}`)\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (error) {\n\t\t\thandleError(error);\n\t\t}\n\t}\n}\n","import Fact from './Fact.js'\n\n/**\n * Cell. A piece of data obtained by defining one element\n * in each dimension of a multidimensional array.\n * The cells of the hypercube can be empty or full.\n *\n * These are aggregated data\n *\n * summary - to describe the values of data in cells\n *\n * each cell is an intersection of all the dimensions of the cube\n * */\nexport default class Cell extends Fact {\n\n}\n","import Cell from './Cell.js'\n\nfunction uuidv4() {\n\treturn 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {\n\t\tlet r = Math.random() * 16 | 0;\n\t\tlet v = c == 'x' ? r : (r & 0x3 | 0x8);\n\t\treturn v.toString(16);\n\t});\n}\n\n/**\n * Empty cells - in the fact table there is no data for them\n * The cell is identified by a tuple\n * */\nexport default class EmptyCell extends Cell {\n\tconstructor(data, options) {\n\t\tif (!data.id) {\n\t\t\tdata.id = EmptyCell.generateId()\n\t\t}\n\t\tsuper(data, options)\n\t}\n\t/**\n\t * @return {EmptyCell}\n\t * */\n\tstatic createEmptyCell(options) {\n\t\treturn new EmptyCell(options)\n\t}\n\t/**\n\t * @param {Cell|{ id: string|number }} cell\n\t * @return {boolean}\n\t * */\n\tstatic isEmptyCell(cell) {\n\t\treturn typeof cell.id === 'string'\n\t}\n\t/**\n\t * @return {string}\n\t * */\n\tstatic generateId() {\n\t\treturn uuidv4()\n\t}\n}\n","/**\n * Element of dimension. Serving to determine the position and description of the data element\n * */\nexport default class Member {\n\tconstructor(data) {\n\t\tObject.assign(this, data);\n\t}\n\tstatic create(id, props, data, primaryKey) {\n\t\tif (!(this === Member || Member.isPrototypeOf(this))) {\n\t\t\tthrow Error('this.constructor must be prototype of Member')\n\t\t}\n\t\tconst memberData = {};\n\t\tmemberData[primaryKey] = id;\n\n\t\tprops.forEach(prop => {\n\t\t\t// исключить идентификатор самой сущности\n\t\t\tif (prop !== primaryKey) {\n\t\t\t\tmemberData[prop] = data[prop]\n\t\t\t}\n\t\t});\n\t\treturn new this(memberData)\n\t}\n}\n","export const DEFAULT_TEMPLATE_FOREIGN_KEY = '%s_id';\nexport const DEFAULT_FACT_ID_PROP = 'id';\nexport const DEFAULT_MEMBER_ID_PROP = 'id';\n","import Member from './Member.js'\n\n/**\n * Introductory elements. Input elements have values that are manually loaded\n * that is, they are not the result of calculating data\n * */\nexport default class InputMember extends Member {\n\tstatic create(id, memberData, data, primaryKey) {\n\t\tconst defaultValue = null;\n\t\tconst defaultData = {};\n\n\t\tmemberData.forEach(propName => {\n\t\t\tdefaultData[propName] = data.hasOwnProperty(propName) ? data[propName] : defaultValue\n\t\t});\n\n\t\treturn super.create(id, memberData, defaultData, primaryKey)\n\t}\n}\n","import Member from './Member.js'\nimport {DEFAULT_MEMBER_ID_PROP, DEFAULT_TEMPLATE_FOREIGN_KEY} from './const.js'\nimport InputMember from './InputMember.js'\n\n/**\n * Dimension is a dimension of a cube. A dimension is a primary organizer of measure and attribute information in a cube\n * A dimension will contain some members organized in some hierarchy or hierarchies containing levels.\n * */\nexport default class DimensionTable {\n\tconstructor({ dimension, foreignKey = DimensionTable.genericId(dimension), primaryKey = DEFAULT_MEMBER_ID_PROP, keyProps, otherProps = [], members = [], defaultMemberOptions = {}}) {\n\t\tif (!dimension || !keyProps) {\n\t\t\tthrow Error('Bad definition DimensionTable, params \\\"dimension\\\" and \\\"keyProps\\\" is required');\n\t\t}\n\t\tif (Object.keys(defaultMemberOptions).indexOf(primaryKey) !== -1) {\n\t\t\tthrow Error('Bad definition DimensionTable, \\\"defaultMemberOptions\\\" must not contain a \\\"primaryKey\\\" property');\n\t\t}\n\t\t/** Name of the dimension */\n\t\tthis.dimension = dimension;\n\t\t/** id name */\n\t\tthis.foreignKey = foreignKey;\n\t\t/** id name */\n\t\tthis.primaryKey = primaryKey;\n\t\t/** List of key names properties of the table belonging to the current dimension */\n\t\tthis.keyProps = [].concat(keyProps);\n\t\t/** List of additional names properties of the table belonging to the current dimension */\n\t\tthis.otherProps = [].concat(otherProps);\n\t\t/** member list */\n\t\tthis.members = members.map(memberData => {\n\t\t\treturn new Member(memberData, this.primaryKey)\n\t\t});\n\t\t/** member default property options */\n\t\tthis.defaultMemberOptions = {...defaultMemberOptions};\n\t}\n\t/**\n\t *\n\t * */\n\tsetMemberList(members) {\n\t\t[].splice.apply(this.members, [0, this.members.length].concat(members))\n\t}\n\t/**\n\t *\n\t * */\n\tclearMemberList() {\n\t\tthis.members = [];\n\t}\n\tgetMemberId(member) {\n\t\treturn member[this.primaryKey]\n\t}\n\t/**\n\t * @param {Member} member\n\t * */\n\taddMember(member) {\n\t\tif (this.members.indexOf(member) === -1) {\n\t\t\tthis.members.push(member)\n\t\t} else {\n\t\t\tconsole.log('boo')\n\t\t}\n\t}\n\t/**\n\t * @public\n\t * @param {object} memberOptions\n\t * @param {[]} linkProps\n\t * */\n\tcreateMember(memberOptions = {}, linkProps) {\n\t\t// todo тут нужна проверка на то, что все данные для члена измерения присутствуют\n\t\tconst memberData = {...this.defaultMemberOptions, ...memberOptions};\n\t\tconst { keyProps, otherProps, members, primaryKey } = this;\n\t\tconst keys = keyProps.concat(linkProps).concat(otherProps);\n\t\tconst id = DimensionTable.reduceId(members, primaryKey);\n\t\tconst member = InputMember.create(id, keys, memberData, primaryKey);\n\t\tthis.addMember(member);\n\t\treturn member;\n\t}\n\t/**\n\t * @public\n\t * Method of generating a unique identifier within the selected space\n\t * */\n\tstatic reduceId(members, primaryKey) {\n\t\tif (members.length) {\n\t\t\treturn members.reduce((acc, curValue) => {\n\t\t\t\treturn acc[primaryKey] > curValue[primaryKey] ? acc : curValue;\n\t\t\t}, 0)[primaryKey] + 1\n\t\t} else {\n\t\t\treturn 1;\n\t\t}\n\t}\n\t/**\n\t * @public\n\t * A way to create a name for a property in which a unique identifier will be stored\n\t * */\n\tstatic genericId(dimension) {\n\t\treturn DEFAULT_TEMPLATE_FOREIGN_KEY.replace('%s', dimension);\n\t}\n\tsetMemberId(member, id) {\n\t\tmember[this.primaryKey] = id;\n\t}\n\tdeleteMemberId(member) {\n\t\tdelete member[this.primaryKey]\n\t}\n\t/**\n\t *\n\t * */\n\tremoveMember(member) {\n\t\tconst index = this.members.indexOf(member);\n\t\tif (index === -1) {\n\t\t\tthrow new Error('represented member was not found', member);\n\t\t}\n\t\tthis.members.splice(index, 1);\n\t}\n\tstatic createDimensionTable(dimensionTable) {\n\t\treturn new DimensionTable(dimensionTable)\n\t}\n}\n","/**\n * Tree traversing https://en.wikipedia.org/wiki/Tree_traversal\n * @class Tree\n * @abstract class cannot be instantiated with new\n * */\nexport default class Tree {\n\t/**\n\t * @public\n\t * @abstract\n\t * @return {Object}\n\t * */\n\tgetTreeValue() {\n\t\tthrow 'abstract method'\n\t}\n\t/**\n\t * @public\n\t * @abstract\n\t * @return {Tree|null}\n\t * */\n\tgetParentTree() {\n\t\tthrow 'abstract method'\n\t}\n\t/**\n\t * @public\n\t * @abstract\n\t * @return {Tree[]}\n\t * */\n\tgetChildTrees() {\n\t\tthrow 'abstract method'\n\t}\n\t/**\n\t * @public\n\t * @return {boolean}\n\t * */\n\tisExternal() {\n\t\treturn !this.getChildTrees().length;\n\t}\n\t/**\n\t * @public\n\t * @return {boolean}\n\t * */\n\tisRoot() {\n\t\treturn this.getParentTree() === null;\n\t}\n\t/**\n\t * @public\n\t * Get root for that tree\n\t * @return {Tree}\n\t * */\n\tgetRoot() {\n\t\tlet root = this;\n\t\tthis.traceUpOrder(tracedTree => {\n\t\t\tif (tracedTree.isRoot()) {\n\t\t\t\troot = tracedTree;\n\t\t\t}\n\t\t});\n\t\treturn root;\n\t}\n\t/**\n\t * @public\n\t * Search method\n\t * @return {Tree|undefined}\n\t * */\n\tsearchTreeByTreeValue(callback) {\n\t\tlet search = void 0;\n\t\tthis.tracePostOrder((treeValue, tree) => {\n\t\t\tif (callback(tree)) {\n\t\t\t\tsearch = tree\n\t\t\t}\n\t\t});\n\t\treturn search;\n\t}\n\t/**\n\t * @public\n\t * A walk to root from current Tree, the current Tree and root entered to the chain\n\t * @param {function} callback\n\t * */\n\ttraceUpOrder(callback) {\n\t\t(function reqursively(tree) {\n\t\t\tconst parentNode = tree.getParentTree();\n\t\t\tcallback(tree);\n\t\t\tif (parentNode !== null) {\n\t\t\t\treqursively(parentNode);\n\t\t\t}\n\t\t}(this));\n\t}\n\t/**\n\t * @public\n\t * A walk in which the children are traversed before their respective parents are traversed\n\t * @param {function} callback\n\t * */\n\ttracePostOrder(callback) {\n\t\t(function reqursively(tree) {\n\t\t\tconst childTrees = tree.getChildTrees();\n\t\t\tconst treeValue = tree.getTreeValue();\n\t\t\tif (childTrees.length) {\n\t\t\t\tchildTrees.forEach(childTree => {\n\t\t\t\t\treqursively(childTree);\n\t\t\t\t});\n\t\t\t}\n\t\t\tcallback(treeValue, tree);\n\t\t}(this));\n\t}\n\t/**\n\t * @public\n\t *  A walk in which each parent tree is traversed before its children is called a pre-order walk\n\t * */\n\ttracePreOrder(callback) {\n\t\t(function reqursively(tree) {\n\t\t\tconst childTrees = tree.getChildTrees();\n\t\t\tconst treeValue = tree.getTreeValue();\n\t\t\tcallback(treeValue, tree);\n\t\t\tif (childTrees.length) {\n\t\t\t\tchildTrees.forEach(childTree => {\n\t\t\t\t\treqursively(childTree);\n\t\t\t\t});\n\t\t\t}\n\t\t}(this));\n\t}\n\t/**\n\t * Check if some thee is present in childs of some level\n\t * @param {Tree}\n\t * @return {boolean}\n\t * */\n\thasChild(tree) {\n\t\tlet has = false;\n\t\tthis.tracePreOrder((tracedTreeValue, tracedTree) => {\n\t\t\tif (tracedTree === tree) {\n\t\t\t\thas = true;\n\t\t\t}\n\t\t});\n\t\treturn has;\n\t}\n\t/**\n\t * Check if some thee is present in parents of some level\n\t * @param {Tree}\n\t * @return {boolean}\n\t * */\n\thasParent(tree) {\n\t\tlet has = false;\n\t\tthis.traceUpOrder((tracedTree) => {\n\t\t\tif (tracedTree === tree) {\n\t\t\t\thas = true;\n\t\t\t}\n\t\t});\n\t\treturn has;\n\t}\n}\n","import DimensionTable from './DimensionTable.js'\nimport Tree from './Tree.js'\nimport {DimensionException} from './errors.js'\n/**\n * It defines the relationship of generalization and specialization (roll-up/drill-down)\n * @throws {DimensionException}\n * */\nexport default class DimensionTree extends Tree {\n\tconstructor(dimensionTree) {\n\t\tsuper();\n\n\t\tconst {dimensionTable, level = [], parentNode = null} = dimensionTree;\n\t\t\n\t\tObject.defineProperties(this, {\n\t\t\tdimensionTable: {\n\t\t\t\t/**\n\t\t\t\t * @property\n\t\t\t\t * @name DimensionTree#dimensionTable\n\t\t\t\t * */\n\t\t\t\tvalue: DimensionTable.createDimensionTable(dimensionTable),\n\t\t\t\teditable: false,\n\t\t\t\tenumerable: true\n\t\t\t},\n\t\t\tparentNode: {\n\t\t\t\t/**\n\t\t\t\t * @property {DimensionTree|null}\n\t\t\t\t * @name DimensionTree#parentNode\n\t\t\t\t * */\n\t\t\t\tvalue: parentNode,\n\t\t\t\tenumerable: false,\n\t\t\t\teditable: false\n\t\t\t},\n\t\t\tlevel: {\n\t\t\t\t/**\n\t\t\t\t * @property {DimensionTree[]}\n\t\t\t\t * @name DimensionTree#level\n\t\t\t\t * */\n\t\t\t\tvalue: level.map(dimensionTreeData => {\n\t\t\t\t\treturn new DimensionTree({ ...dimensionTreeData, parentNode: this })\n\t\t\t\t}),\n\t\t\t\tenumerable: true,\n\t\t\t\teditable: false\n\t\t\t}\n\t\t});\n\t\tthis.validate();\n\t}\n\tvalidate(){\n\t\tconst dimensions = [];\n\t\tthis.tracePostOrder((tracedDimensionTreeValue) => {\n\t\t\tconst {dimension} = tracedDimensionTreeValue;\n\t\t\tif (dimensions.indexOf(dimension) === -1){\n\t\t\t\tdimensions.push(dimension)\n\t\t\t} else {\n\t\t\t\tthrow new DimensionException();\n\t\t\t}\n\t\t})\n\t}\n\tstatic createDimensionTree(dimensionTreeData) {\n\t\treturn new DimensionTree(dimensionTreeData);\n\t}\n\tstatic createProxyDimensionTree(dimensionTree){\n\t\tconst newDimensionTree = dimensionTree.cloneDimensionTreeWithoutMembers();\n\t\tdimensionTree.tracePostOrder((tracedTreeValue) => {\n\t\t\tconst { dimension: tracedDimension, members } = tracedTreeValue;\n\t\t\t\n\t\t\tnewDimensionTree\n\t\t\t\t.getDimensionTreeByDimension(tracedDimension)\n\t\t\t\t.getTreeValue()\n\t\t\t\t.setMemberList(members);\n\t\t});\n\t\treturn newDimensionTree;\n\t}\n\t/**\n\t * @public\n\t * @return {DimensionTable}\n\t * */\n\tgetTreeValue() {\n\t\treturn this.dimensionTable;\n\t}\n\t/**\n\t * @public\n\t * @return {DimensionTree|null}\n\t * */\n\tgetParentTree() {\n\t\treturn this.parentNode;\n\t}\n\t/**\n\t * @public\n\t * @return {DimensionTree[]}\n\t * */\n\tgetChildTrees() {\n\t\treturn this.level;\n\t}\n\t/**\n\t * @public\n\t * @param {string} dimension\n\t * @return {DimensionTree|undefined}\n\t * */\n\tgetDimensionTreeByDimension(dimension) {\n\t\treturn this.getRoot().searchTreeByTreeValue(dimensionTree => {\n\t\t\tconst dimensionTreeValue = dimensionTree.getTreeValue();\n\t\t\treturn dimensionTreeValue.dimension === dimension;\n\t\t});\n\t}\n\t/**\n\t * @public\n\t * @param {Member} member\n\t * @return {DimensionTree|undefined}\n\t * */\n\tcreateProjectionOntoMember(member) {\n\t\t// 1 create copy of hierarchy with empty members\n\t\tconst newDimensionTreeByMember = this.cloneDimensionTreeWithoutMembers();\n\n\t\tthis.projectDrillDown(newDimensionTreeByMember, member);\n\t\tthis.projectDrillUp(newDimensionTreeByMember, member);\n\n\t\treturn newDimensionTreeByMember;\n\t}\n\t// насытить связными данными снизу\n\tprojectDrillDown(dimensionTree, member){\n\t\tlet lastTracedMembers;\n\t\tlet lastTracedDimensionTree;\n\t\t// 2 trace up\n\t\tthis.traceUpOrder(tracedTree => {\n\t\t\tconst { dimension: tracedDimension } = tracedTree.getTreeValue();\n\n\t\t\t// 3 get drill down of last members\n\t\t\tconst drillDownedMembers = tracedTree == this\n\t\t\t\t? [member]\n\t\t\t\t: lastTracedDimensionTree.drillDownDimensionMembers(lastTracedMembers);\n\n\t\t\t// 4 set members\n\t\t\tdimensionTree\n\t\t\t\t.getDimensionTreeByDimension(tracedDimension)\n\t\t\t\t.getTreeValue()\n\t\t\t\t.setMemberList(drillDownedMembers);\n\n\t\t\t// 5 save current dimension and drill downed members\n\t\t\tlastTracedMembers = drillDownedMembers;\n\t\t\tlastTracedDimensionTree = tracedTree;\n\t\t});\n\t}\n\t// насытить связными данными сверху\n\tprojectDrillUp(dimensionTree, member){\n\t\tlet lastTracedMembers2;\n\t\tlet lastTracedDimensionTree2;\n\t\tthis.tracePreOrder((b, tracedTree) => {\n\t\t\tconst { dimension: tracedDimension } = tracedTree.getTreeValue();\n\t\t\tconst drillUppedMembers = tracedTree == this\n\t\t\t\t? [member]\n\t\t\t\t: lastTracedDimensionTree2.drillUpDimensionMembers(lastTracedMembers2);\n\n\t\t\tdimensionTree\n\t\t\t\t.getDimensionTreeByDimension(tracedDimension)\n\t\t\t\t.getTreeValue()\n\t\t\t\t.setMemberList(drillUppedMembers);\n\n\t\t\tlastTracedMembers2 = drillUppedMembers;\n\t\t\tlastTracedDimensionTree2 = tracedTree;\n\t\t})\n\t}\n\tcloneDimensionTreeWithoutMembers(){\n\t\t// todo new members must be not created here\n\t\tconst clone = new DimensionTree(this.getRoot());\n\t\tclone.tracePostOrder((dimensionTreeValue, dimensionTree) => {\n\t\t\tconst dimensionTable = dimensionTree.getTreeValue();\n\t\t\tdimensionTable.clearMemberList();\n\t\t});\n\t\treturn clone;\n\t}\n\t/**\n\t * @public\n\t * @param {Member} member\n\t * */\n\tremoveProjectionOntoMember(member) {\n\t\t// 1 get projection\n\t\tconst projectionDimensionTree = this.cloneDimensionTreeWithoutMembers();\n\t\tthis.projectDrillDown(projectionDimensionTree, member);\n\n\t\t// 2 subtract projection\n\t\tthis.subtractDimensionTree(projectionDimensionTree);\n\t\t// 3 return first level members of projection\n\t\tconst endToBeRemovedMember = {};\n\n\t\tconst {\n\t\t\tdimension: dimensionProjection,\n\t\t\tmembers: membersProjection\n\t\t} = projectionDimensionTree.getRoot().getTreeValue();\n\n\t\tendToBeRemovedMember[dimensionProjection] = membersProjection;\n\n\t\treturn endToBeRemovedMember;\n\t}\n\t/**\n\t * @private\n\t * @param {DimensionTree} dimensionTree\n\t * */\n\tsubtractDimensionTree(dimensionTree) {\n\t\t// remove intersection\n\t\tconst toBeRemovedSpace = {};\n\n\t\tdimensionTree.tracePostOrder(dimensionTreeValue => {\n\t\t\tconst {dimension, members} = dimensionTreeValue;\n\t\t\ttoBeRemovedSpace[dimension] = members;\n\t\t});\n\n\t\tconst memberList = this.getTreeValue().members;\n\n\t\t// travers down\n\t\tif (memberList.length === 1) {\n\t\t\tthis.tracePreOrder((dimensionTable, tracedDimensionTree) => {\n\t\t\t\tconst {members: childMembers, dimension: childDimension} = dimensionTable;\n\t\t\t\ttoBeRemovedSpace[childDimension] = childMembers;\n\t\t\t})\n\t\t}\n\n\t\t// remove removal space\n\t\tObject.keys(toBeRemovedSpace).forEach(dimension => {\n\t\t\tconst currentDimensionTree = this.getDimensionTreeByDimension(dimension);\n\t\t\tconst dimensionTable = currentDimensionTree.getTreeValue();\n\t\t\ttoBeRemovedSpace[dimension].forEach(member => {\n\t\t\t\tdimensionTable.removeMember(member);\n\t\t\t})\n\t\t});\n\t}\n\tunionDimensionTree(dimensionTree){\n\t\tconst toBeAddedSpace = {};\n\t\tdimensionTree.tracePostOrder(dimensionTreeValue => {\n\t\t\tconst {dimension, members} = dimensionTreeValue;\n\t\t\ttoBeAddedSpace[dimension] = members;\n\t\t});\n\t\tconst memberList = this.getTreeValue().members;\n\n\t\t// if (memberList.length === 1){\n\t\t// \tthis.tracePreOrder((dimensionTable, tracedDimensionTree) => {\n\t\t// \t\tconst {members: childMembers, dimension: childDimension} = dimensionTable;\n\t\t// \t\ttoBeAddedSpace[childDimension] = childMembers;\n\t\t// \t})\n\t\t// }\n\t\tObject.keys(toBeAddedSpace).forEach(dimension => {\n\t\t\tconst currentDimensionTree = this.getDimensionTreeByDimension(dimension);\n\t\t\tconst dimensionTable = currentDimensionTree.getTreeValue();\n\t\t\ttoBeAddedSpace[dimension].forEach(member => {\n\t\t\t\tdimensionTable.addMember(member);\n\t\t\t})\n\t\t});\n\t}\n\t/**\n\t * @public\n\t * @param {Member[]} members\n\t * @return {Member[]}\n\t * */\n\tdrillDownDimensionMembers(members = this.getTreeValue().members) {\n\t\tif (this.isRoot()) {\n\t\t\treturn members;\n\t\t}\n\t\tconst parentTree = this.getParentTree();\n\t\tconst { members: parentMembers, primaryKey } = parentTree.getTreeValue();\n\t\tconst dimensionTable = this.getTreeValue();\n\t\tconst { foreignKey } = dimensionTable;\n\t\tconst drillDownMembers = [];\n\t\tmembers.forEach(member => {\n\t\t\tparentMembers.forEach(parentMember => {\n\t\t\t\tif (parentMember[foreignKey] === member[primaryKey]) {\n\t\t\t\t\tif (drillDownMembers.indexOf(parentMember) === -1) {\n\t\t\t\t\t\tdrillDownMembers.push(parentMember)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t})\n\t\t});\n\t\treturn drillDownMembers;\n\t}\n\t/**\n\t * @public\n\t * @this {DimensionTree}\n\t * @param {Member[]} members\n\t * @return {Member[]}\n\t * */\n\tdrillUpDimensionMembers(members = this.getTreeValue().members) {\n\t\tif (this.isExternal()) {\n\t\t\treturn members;\n\t\t}\n\t\tconst childTree = this.getChildTrees()[0]; // for one child always\n\t\tconst dimensionTable = childTree.getTreeValue();\n\t\tconst { members: childMembers, foreignKey } = dimensionTable;\n\t\tconst rollUpMembers = [];\n\t\tmembers.forEach(member => {\n\t\t\tchildMembers.forEach(childMember => {\n\t\t\t\tif (member[foreignKey] === dimensionTable.getMemberId(childMember)) {\n\t\t\t\t\tif (rollUpMembers.indexOf(childMember) === -1) {\n\t\t\t\t\t\trollUpMembers.push(childMember)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t})\n\t\t});\n\t\treturn rollUpMembers;\n\t}\n\t/**\n\t * @public\n\t * @param {object?} memberOptions\n\t * */\n\tcreateMember(memberOptions = {}) {\n\t\tconst dimensionTable = this.getTreeValue();\n\t\tconst childIdAttributes = this.getChildTrees().map(dimensionTree =>\n\t\t\tdimensionTree.getTreeValue().foreignKey\n\t\t);\n\t\tconst linkProps = [];\n\t\tchildIdAttributes.forEach(foreignKey => {\n\t\t\tlinkProps.push(foreignKey)\n\t\t});\n\t\treturn dimensionTable.createMember(memberOptions, linkProps)\n\t}\n}\n","import DimensionTree from './DimensionTree.js'\n\n/**\n * The elements of a dimension can be organized as a hierarchy\n * Hierarchy is a dimension hierarchy of a cube\n * */\nexport default class DimensionHierarchy {\n\tconstructor({ dimensionTree, activeDimension, hierarchy}) {\n\t\tif (!hierarchy) {\n\t\t\tthrow Error('attribute \"hierarchy\" must be defined')\n\t\t}\n\t\tthis.dimensionTree = dimensionTree instanceof DimensionTree\n\t\t\t? dimensionTree\n\t\t\t: DimensionTree.createDimensionTree(dimensionTree);\n\t\tthis.activeDimension = activeDimension || this.dimensionTree.getTreeValue().dimension;\n\t\tthis.hierarchy = hierarchy;\n\t}\n\tgetDimensionTree() {\n\t\treturn this.dimensionTree;\n\t}\n\thasDimension(dimension) {\n\t\treturn !!this.dimensionTree.getDimensionTreeByDimension(dimension);\n\t}\n\tgetActiveDimension() {\n\t\treturn this.activeDimension;\n\t}\n\tsetActiveDimension(activeDimension) {\n\t\tthis.activeDimension = activeDimension;\n\t}\n\tgetHierarchy() {\n\t\treturn this.hierarchy;\n\t}\n\tstatic createDimensionHierarchy(dimensionHierarchy) {\n\t\treturn new DimensionHierarchy(dimensionHierarchy)\n\t}\n}\n","import Fact from './Fact.js'\nimport { DEFAULT_FACT_ID_PROP } from './const.js'\nimport {NotFoundFactId} from './errors.js'\n\n/**\n * @throw {NotFoundFactId}\n * */\nexport default class FactTable {\n\tconstructor({ facts = [], primaryKey = DEFAULT_FACT_ID_PROP } = {}, defaultFactOptions = {}) {\n\t\tthis.primaryKey = primaryKey;\n\t\tthis.facts = facts.map(factData => new Fact(factData));\n\t\tthis.defaultFactOptions = defaultFactOptions;\n\t\tthis.facts.forEach(this.validateFactData.bind(this))\n\t}\n\tgetFacts() {\n\t\treturn this.facts;\n\t}\n\tvalidateFactData(factData) {\n\t\tif (!factData.hasOwnProperty(this.primaryKey)) {\n\t\t\tthrow new NotFoundFactId(this.primaryKey)\n\t\t}\n\t}\n\tstatic deleteProps(fact, props, primaryKey) {\n\t\tprops.forEach(prop => {\n\t\t\tif (prop !== primaryKey) {\n\t\t\t\tdelete fact[prop];\n\t\t\t}\n\t\t});\n\t}\n}\n","import FactTable from './FactTable.js'\nimport Member from './Member.js'\n\n/**\n * The main task is to parse the data array into tables\n *\n * is a special case of snowflake dimensionHierarchies\n * where every dimension is represented by one table even if the dimensions has multiple levels\n *\n * snowflaking - normalization process of measurement tables\n * */\nexport default class SnowflakeBuilder {\n\tstatic anotherBuild(factTable, cells, dimensionsTrees, cellTable, factPrimaryKey) {\n\n\t\t// for each dimension\n\t\tdimensionsTrees.forEach(dimensionTree => {\n\t\t\tSnowflakeBuilder.anotherBuildOne(dimensionTree, cells, cellTable, factTable, factPrimaryKey);\n\t\t});\n\t}\n\n\tstatic anotherBuildOne(dimensionTree, cells, cellTable, factTable, factPrimaryKey) {\n\t\t// for each hierarchy and level of dimension\n\t\tdimensionTree.tracePostOrder((dimensionTable, dimensionTree) => {\n\t\t\tSnowflakeBuilder.processDimension(dimensionTree, cells, cellTable, factTable, factPrimaryKey)\n\t\t});\n\t}\n\n\tstatic processDimension(dimensionTree, cells, cellTable, factTable, factPrimaryKey) {\n\t\tconst dimensionTable = dimensionTree.getTreeValue();\n\t\tconst { dimension, keyProps = [], otherProps = [], members: memberList, foreignKey, primaryKey } = dimensionTable;\n\t\tconst childIdAttributes = dimensionTree.getChildTrees().map(dimensionTree => dimensionTree.getTreeValue().foreignKey);\n\t\tconst childDimensions = dimensionTree.getChildTrees().map(dimensionTree => dimensionTree.getTreeValue().dimension);\n\n\t\tlet members;\n\n\t\tconst existMemberCount = memberList.length;\n\t\tconst args = [factPrimaryKey, primaryKey, foreignKey, existMemberCount, factTable, cells, dimension, keyProps, otherProps, cells, cellTable];\n\n\t\tif (!childIdAttributes.length) {\n\t\t\tmembers = SnowflakeBuilder.makeMemberList.apply(null, args);\n\t\t} else {\n\t\t\tlet entitiesParts = [];\n\t\t\tconst dimensionTable = dimensionTree.getDimensionTreeByDimension(childDimensions[0]).getTreeValue();\n\t\t\tconst memberListForFilter = dimensionTable.members;\n\t\t\tentitiesParts = SnowflakeBuilder.mapFilter(childIdAttributes[0], cells, memberListForFilter, dimensionTable);\n\t\t\tmembers = SnowflakeBuilder.makeMemberListLevel.apply(null, args.concat([childIdAttributes, entitiesParts]));\n\t\t}\n\n\t\t// только после того как список сформирован, удалаять данные из ячеек\n\t\tcells.forEach(cell => {\n\t\t\tFactTable.deleteProps(cell, keyProps, factPrimaryKey);\n\t\t\tFactTable.deleteProps(cell, otherProps, factPrimaryKey);\n\t\t});\n\n\t\tmembers.forEach(member => {\n\t\t\tdimensionTable.addMember(member)\n\t\t});\n\t}\n\t/**\n\t * Method filter cells by members of a dimension\n\t * @param {string} foreignKey\n\t * @param {Cell[]} cells\n\t * @param {Member[]} memberList\n\t * @param {DimensionTable} dimensionTable\n\t * @private\n\t * @return {Cell[]}\n\t * */\n\tstatic mapFilter(foreignKey, cells, memberList, dimensionTable) {\n\t\tconst cellTables = [];\n\t\t//todo оптимизировать поиск через хеш\n\t\tmemberList.forEach(member => {\n\t\t\tconst cellTableFiltered = cells.filter(cell => {\n\t\t\t\treturn cell[foreignKey] == dimensionTable.getMemberId(member);\n\t\t\t});\n\t\t\tcellTables.push(cellTableFiltered);\n\t\t});\n\t\treturn cellTables;\n\t}\n\t/**\n\t * @private\n\t * */\n\tstatic makeMemberListLevel(factPrimaryKey, primaryKey, foreignKey, existMemberCount, factTable, whatIsIt, dimension, keyProps, otherProps, cells, cellTable, childIdAttributes, entitiesParts) {\n\t\tlet totalMemberList = [];\n\n\t\tlet countId = 0;\n\t\tentitiesParts.forEach(entitiesPart => {\n\t\t\tif (entitiesPart.length) {\n\t\t\t\tconst members = SnowflakeBuilder.makeMemberList(factPrimaryKey, primaryKey, foreignKey, existMemberCount, factTable, entitiesPart, dimension, keyProps, otherProps, cells, cellTable, countId);\n\t\t\t\tcountId = countId + members.length;\n\n\t\t\t\tconst etalon = entitiesPart[0];\n\n\t\t\t\tchildIdAttributes.forEach(childIdAttribute => {\n\n\t\t\t\t\tmembers.forEach(member => {\n\t\t\t\t\t\tmember[childIdAttribute] = etalon[childIdAttribute];\n\t\t\t\t\t\tmember[primaryKey] = (existMemberCount + totalMemberList.length + 1);\n\t\t\t\t\t\ttotalMemberList.push(member)\n\t\t\t\t\t});\n\n\t\t\t\t\tentitiesPart.forEach(entityPart => {\n\t\t\t\t\t\tdelete entityPart[childIdAttribute];\n\t\t\t\t\t})\n\n\t\t\t\t});\n\t\t\t}\n\t\t});\n\n\t\treturn totalMemberList;\n\t}\n\n\t/**\n\t * The method of analyzing the data array and generating new dimension values\n\t *\n\t * @param {object[]} entitiesPart - Data array to the analysis of values for dimension\n\t * @param {number} startFrom\n\t * @param {string} dimension - The dimension for which members will be created\n\t * @param {string[]} keyProps - Names of properties whose values will be used to generate a key that will determine the uniqueness of the new member for dimension\n\t * @param {string[]} otherProps - Names of properties whose values will be appended to the dimension member along with the key properties\n\t * @param {Cell} cells\n\t * @param {Cell[]} cellTable\n\t * @return {[]}\n\t * @private\n\t * */\n\tstatic makeMemberList(\n\t\tfactPrimaryKey,\n\t\tprimaryKey,\n\t\tforeignKey,\n\t\texistMemberCount,\n\t\tfactTable,\n\t\tentitiesPart,\n\t\tdimension,\n\t\tkeyProps = [],\n\t\totherProps = [],\n\t\tcells,\n\t\tcellTable,\n\t\t// It is recommended that the key field be a simple integer because a key value is meaningless\n\t\tstartFrom = 0\n\t) {\n\t\t// соотношение созданных id к ключам\n\t\tconst cache = {};\n\t\tconst restoredCache = {};\n\t\tconst members = [];\n\n\t\t// need restore cache\n\t\tconst existedCells = cellTable.filter(cell => {\n\t\t\treturn cells.indexOf(cell) === -1\n\t\t});\n\t\texistedCells.forEach(cell => {\n\t\t\t// собрать ключ на основе ключевых значений\n\t\t\tconst fact = factTable.find(fact => fact[factPrimaryKey] === cell[factPrimaryKey]);\n\t\t\tconst surrogateKey = SnowflakeBuilder.createKeyFromProps(keyProps, fact);\n\t\t\t// если ключ уникальный создается подсущность и назначается ей присваивается уникальный id (уникальность достигается простым счетчиком)\n\t\t\tif (!(surrogateKey in restoredCache)) {\n\t\t\t\trestoredCache[surrogateKey] = ++startFrom;\n\t\t\t}\n\t\t});\n\n\t\t// создания групп по уникальным ключам\n\t\tentitiesPart.forEach(entityPart => {\n\n\t\t\t// собрать ключ на основе ключевых значений\n\t\t\tconst surrogateKey = SnowflakeBuilder.createKeyFromProps(keyProps, entityPart);\n\n\t\t\t// если ключ уникальный создается подсущность и назначается ей присваивается уникальный id (уникальность достигается простым счетчиком)\n\t\t\tif (!(surrogateKey in cache) && !(surrogateKey in restoredCache)) {\n\t\t\t\tcache[surrogateKey] = ++startFrom;\n\t\t\t}\n\n\t\t\t// оставить в нормальной форме ссылку на id под сущности\n\t\t\tconst id = cache[surrogateKey];\n\t\t\tentityPart[foreignKey] = id;\n\t\t});\n\n\t\tObject.keys(cache).forEach(key => {\n\t\t\tconst id = cache[key];\n\t\t\tconst entityPart = entitiesPart.find(entityPart => entityPart[foreignKey] === id);\n\t\t\tconst member = Member.create(id, [].concat(keyProps).concat(otherProps), entityPart, primaryKey);\n\t\t\tmembers.push(member);\n\t\t});\n\n\t\treturn members;\n\t}\n\n\tstatic createKeyFromProps(props, obj) {\n\t\tconst DIVIDER = ',';\n\n\t\treturn props.map(prop => {\n\t\t\treturn obj[prop]\n\t\t}).join(DIVIDER);\n\t}\n\n\tstatic destroy(cellTable, removedCells, dimensionHierarchies, cube) {\n\t\t// first remove cells\n\t\tremovedCells.forEach(removedCell => {\n\t\t\tconst index = cellTable.indexOf(removedCell);\n\t\t\tif (index !== -1) {\n\t\t\t\tcellTable.splice(index, 1);\n\t\t\t}\n\t\t});\n\t\t// then remove members\n\t\tremovedCells.forEach(fact => {\n\t\t\tdimensionHierarchies.forEach(dimensionTree => {\n\t\t\t\tSnowflakeBuilder.travers([fact], dimensionTree, [SnowflakeBuilder.removeMembers.bind(this, cube, dimensionTree), SnowflakeBuilder.restoreCell]);\n\t\t\t});\n\t\t});\n\t}\n\n\t/**\n\t * Method allows to generate fact tables from cells\n\t * */\n\tstatic denormalize(cellTable, dimensionTrees) {\n\t\tconst factTable = new FactTable();\n\t\tconst facts = factTable.getFacts();\n\t\tcellTable.forEach(cell => {\n\t\t\tfacts.push({...cell})\n\t\t});\n\t\tfacts.forEach(fact => {\n\t\t\tdimensionTrees.forEach(dimensionTree => {\n\t\t\t\tSnowflakeBuilder.travers([fact], dimensionTree, [SnowflakeBuilder.restoreCell]);\n\t\t\t});\n\t\t});\n\n\t\treturn facts;\n\t}\n\tstatic restoreCell(member, memberList, dimension, cell, foreignKey, dimensionTable) {\n\t\tconst memberCopy = new Member(member);\n\t\tdimensionTable.deleteMemberId(memberCopy);\n\t\tdelete cell[foreignKey];\n\t\tObject.assign(cell, memberCopy)\n\t}\n\tstatic removeMembers(cube, dimensionTree, member, memberList, dimension, cell, foreignKey) {\n\t\tconst dicedCube = cube.dice({ [dimension]: member });\n\t\tconst dimensionTable = dimensionTree.getDimensionTreeByDimension(dimension).getTreeValue();\n\t\t// last cell was removed at the beginning of the algorithm,\n\t\t// so if the member is no longer used, the projection will be empty\n\t\tif (!dicedCube.getCells().length) {\n\t\t\tdimensionTable.removeMember(member)\n\t\t}\n\t}\n\n\tstatic travers(cellTable, dimensionTree, handlers = () => {}) {\n\t\tconst handleDimensionTree = (dimensionTree, cell) => {\n\t\t\tconst dimensionTable = dimensionTree.getTreeValue();\n\t\t\tconst { dimension, members: memberList, foreignKey } = dimensionTable;\n\t\t\tconst idValue = cell[foreignKey];\n\t\t\tconst member = memberList.find(member => {\n\t\t\t\treturn dimensionTable.getMemberId(member) === idValue;\n\t\t\t});\n\t\t\thandlers.forEach(handler => {\n\t\t\t\thandler(member, memberList, dimension, cell, foreignKey, dimensionTable);\n\t\t\t})\n\t\t};\n\t\tcellTable.forEach(cell => {\n\t\t\tdimensionTree.tracePreOrder((value, tracedDimensionTree) => {\n\t\t\t\thandleDimensionTree(tracedDimensionTree, cell)\n\t\t\t})\n\t\t});\n\t}\n\n\t/**\n\t * Method allows to delete dimensionTree from cube,\n\t * the cells will be restored, and the members of the measurement are also deleted\n\t * */\n\tstatic destroyDimensionTree(cellTable, removedCells, dimensionTree, cube) {\n\t\tSnowflakeBuilder.travers(cellTable, dimensionTree, [SnowflakeBuilder.removeMembers.bind(this, cube, dimensionTree), SnowflakeBuilder.restoreCell]);\n\t}\n\n}\n","/**\n * The cell is identified by a tuple\n * tuples can uniquely identify every cell in the cube\n * Tuple is an ordered collection of one or more members from different dimensions\n * */\nexport default class Tuple {\n\tconstructor(options) {\n\t\tObject.assign(this, options)\n\t}\n}\n","export default class Space {\n\t/**\n\t *\n\t * */\n\tstatic union() {\n\t\tconst newSpace = {};\n\t\tconst arg = [...arguments];\n\t\targ.forEach(space => {\n\t\t\tSpace.add(newSpace, space);\n\t\t});\n\t\treturn newSpace;\n\t}\n\t/**\n\t *\n\t * */\n\tstatic add(targetSpace, otherSpace) {\n\t\tObject.keys(otherSpace).forEach(key => {\n\t\t\tif (!targetSpace[key]) {\n\t\t\t\ttargetSpace[key] = [];\n\t\t\t}\n\t\t\tArray.prototype.push.apply(targetSpace[key], otherSpace[key])\n\t\t})\n\t}\n}\n","import EmptyCell from './EmptyCell.js'\nimport Member from './Member.js'\nimport DimensionTree from './DimensionTree.js'\nimport DimensionHierarchy from './DimensionHierarchy.js'\nimport DimensionTable from './DimensionTable.js'\nimport FactTable from './FactTable.js'\nimport {\n\tInsufficientRollupData,\n\tCreateInstanceException\n} from './errors.js';\nimport SnowflakeBuilder from './SnowflakeBuilder.js'\nimport console from './console.js'\nimport Tuple from './Tuple.js'\nimport Space from './Space.js'\nimport Cell from './Cell.js'\nimport { DEFAULT_FACT_ID_PROP } from './const.js'\n\nclass CellTable {\n\tconstructor({ cells, primaryKey, defaultFactOptions = {} }) {\n\t\tthis.cells = cells.map(cellData => {\n\t\t\tif (cellData instanceof Cell) {\n\t\t\t\treturn cellData\n\t\t\t} else {\n\t\t\t\treturn EmptyCell.isEmptyCell(cellData) ? new EmptyCell(cellData) : new Cell(cellData)\n\t\t\t}\n\t\t});\n\t\tthis.primaryKey = primaryKey;\n\t\tthis.defaultFactOptions = defaultFactOptions;\n\t}\n}\n\n/**\n * It a means to retrieve data\n *\n * Base class for normalizing a denormalized data array\n * and analyzing query according to a given scheme\n *\n * @param {{snowflake, dimensionHierarchies}|Cube} factTable - facts which will be subject to analysis\n * */\nclass Cube {\n\tconstructor(cube) {\n\t\tlet { dimensionHierarchies = [], cellTable = {} } = cube;\n\t\tif (Array.isArray(cellTable)) {\n\t\t\tcellTable = { cells: cellTable };\n\t\t\tconsole.warnOnce('first argument \\\"cells\\\" as array type is deprecated now, use object for describe fact table')\n\t\t}\n\t\tconst { cells = [], primaryKey = DEFAULT_FACT_ID_PROP, defaultFactOptions = {} } = cellTable;\n\n\t\tthis.dimensionHierarchies = dimensionHierarchies.map(dimensionHierarchy => {\n\t\t\t// duck\n\t\t\tif (dimensionHierarchy.hierarchy) {\n\t\t\t\tif (dimensionHierarchy instanceof DimensionHierarchy) {\n\t\t\t\t\treturn dimensionHierarchy;\n\t\t\t\t} else {\n\t\t\t\t\treturn DimensionHierarchy.createDimensionHierarchy(dimensionHierarchy);\n\t\t\t\t}\n\t\t\t} else if (dimensionHierarchy.dimensionTable) {\n\t\t\t\tif ( dimensionHierarchy instanceof DimensionTree ){\n\t\t\t\t\treturn dimensionHierarchy;\n\t\t\t\t} else {\n\t\t\t\t\treturn DimensionTree.createDimensionTree(dimensionHierarchy);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (dimensionHierarchy instanceof DimensionTable) {\n\t\t\t\t\treturn dimensionHierarchy;\n\t\t\t\t} else {\n\t\t\t\t\treturn DimensionTable.createDimensionTable(dimensionHierarchy);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t\tthis.cellTable = new CellTable({ cells, primaryKey, defaultFactOptions: {...defaultFactOptions} });\n\t\t// const residuals = residuals(this);\n\t\t// const count = residuals.length;\n\t\t// if (count > 0) {\n\t\t// \tconsole.warn('Fact table has residuals', residuals)\n\t\t// }\n\t}\n\t/**\n\t * @public\n\t * Fabric method for creating cube from facts and dimensionHierarchiesData data\n\t * @param {object} factTable\n\t * @param {object} dimensionHierarchies\n\t * @return {Cube}\n\t * */\n\tstatic create(factTable, dimensionHierarchies = []) {\n\t\tif (Array.isArray(factTable)) {\n\t\t\tfactTable = { facts: factTable };\n\t\t\tconsole.warnOnce('first argument \\\"facts\\\" as array type is deprecated now, use object for describe fact table')\n\t\t}\n\t\tconst { facts = [], primaryKey, defaultFactOptions = {} } = factTable;\n\t\tif (!(Cube.isPrototypeOf(this) || Cube === this)) {\n\t\t\tthrow new CreateInstanceException()\n\t\t}\n\n\t\tconst cube = new this({\n\t\t\tcellTable: { primaryKey, defaultFactOptions },\n\t\t\tdimensionHierarchies: dimensionHierarchies,\n\t\t});\n\n\t\t// build 2: members\n\t\tcube.addFacts(facts);\n\n\t\treturn cube;\n\t}\n\t/**\n\t * is the act of picking a rectangular subset of a cube by choosing a single value\n\t * for one of its dimensions, creating a new cube with one fewer dimension.\n\t * @public\n\t * @param {string} dimension\n\t * @param {Member} member\n\t * @return {Cube}\n\t * */\n\tslice(dimension, member) {\n\t\treturn this.dice({ [dimension]: member })\n\t}\n\t/**\n\t * @public\n\t * @param {object} set\n\t * @return {Cube}\n\t * */\n\tdice(set) {\n\t\t// 1 make one projection on to member\n\t\tconst fixSpace = {};\n\t\tObject.keys(set).forEach(dimension => {\n\t\t\t// work with arrays\n\t\t\tfixSpace[dimension] = Array.isArray(set[dimension])\n\t\t\t\t? set[dimension]\n\t\t\t\t: [set[dimension]];\n\n\t\t\tconst dimensionTree = findDimensionTreeByDimension.call(this, dimension);\n\t\t\t\n\t\t\t// discard non-existent dimensions\n\t\t\tif (!dimensionTree) {\n\t\t\t\tconsole.warn(`Not existed dimension: ${dimension}`);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tconst dimensionTable = dimensionTree.getTreeValue();\n\t\t\tfixSpace[dimension].forEach((memberData, index) => {\n\t\t\t\tconst members = this.getDimensionMembers(dimension);\n\t\t\t\tlet member = members.find(member => dimensionTable.getMemberId(member) === dimensionTable.getMemberId(memberData));\n\t\t\t\tfixSpace[dimension][index] = member;\n\t\t\t\tif (!memberData) {\n\t\t\t\t\tconsole.warn(`Not found member by id ${dimensionTable.getMemberId(member)}`)\n\t\t\t\t}\n\t\t\t})\n\t\t});\n\n\t\tconst dimensionHierarchiesLength = this.dimensionHierarchies.length;\n\t\tif (Object.keys(fixSpace).length > dimensionHierarchiesLength) {\n\t\t\tthrow Error(`Set must have a size not more than ${dimensionHierarchiesLength} dimensions`)\n\t\t}\n\n\t\tconst projectionDimensionHierarchies = [];\n\n\t\t// for every dimension in set\n\t\tconst totalSpaces = Object.keys(fixSpace).map(dimension => {\n\n\t\t\tlet dimensionTreeProjection;\n\t\t\t// ищется его расширенная версия для каждого члена\n\t\t\tconst spacesForCells = fixSpace[dimension].map(member => {\n\n\t\t\t\tlet searchedInTree = findDimensionTreeByDimension.call(this, dimension);\n\n\t\t\t\tconst current = searchedInTree.cloneDimensionTreeWithoutMembers();\n\n\t\t\t\tsearchedInTree.projectDrillDown(current, member);\n\t\t\t\tsearchedInTree.projectDrillUp(current, member);\n\n\t\t\t\tif (dimensionTreeProjection){\n\t\t\t\t\tdimensionTreeProjection.unionDimensionTree(current)\n\t\t\t\t} else {\n\t\t\t\t\tdimensionTreeProjection = current;\n\t\t\t\t}\n\t\t\t\tconst {\n\t\t\t\t\tdimension: dimensionProjection,\n\t\t\t\t\tmembers: membersProjection\n\t\t\t\t} = dimensionTreeProjection.getRoot().getTreeValue();\n\n\t\t\t\treturn { [dimensionProjection]: membersProjection };\n\t\t\t});\n\n\t\t\tif (dimensionTreeProjection){\n\t\t\t\tprojectionDimensionHierarchies.push(dimensionTreeProjection);\n\t\t\t}\n\n\t\t\t// после чего эти расширенные версии объекдиняются\n\t\t\tconst totalSpace = Space.union(...spacesForCells);\n\n\t\t\treturn totalSpace;\n\t\t});\n\n\t\t// фильтрация продолжается\n\t\tlet filteredCellTable = this.getCells();\n\n\t\tconst cellBelongsToSpace = (cell, space) => {\n\t\t\tconst somePropOfCellNotBelongToSpace = Object.keys(space).some(dimension => {\n\t\t\t\tconst members = space[dimension];\n\t\t\t\tconst { foreignKey, primaryKey } = findDimensionTreeByDimension.call(this, dimension).getTreeValue();\n\t\t\t\tconst finded = members.find(member => {\n\t\t\t\t\treturn member[primaryKey] === cell[foreignKey]\n\t\t\t\t});\n\t\t\t\treturn !finded;\n\t\t\t});\n\t\t\treturn !somePropOfCellNotBelongToSpace;\n\t\t};\n\n\t\ttotalSpaces.forEach(space => {\n\t\t\t// и ищутся те ячейки, которые принадлежат получившейся области\n\t\t\tfilteredCellTable = filteredCellTable.filter(cell => {\n\t\t\t\treturn cellBelongsToSpace(cell, space)\n\t\t\t});\n\t\t});\n\n\t\t// 2 create new list of dimensionHierarchies\n\t\tconst newDimensionHierarchies = [];\n\t\tthis.dimensionHierarchies.forEach(originalDimensionHierarchy => {\n\t\t\tlet finded = false;\n\t\t\tprojectionDimensionHierarchies.forEach(projectionDimensionHierarchy => {\n\t\t\t\tif (originalDimensionHierarchy.getTreeValue().dimension === projectionDimensionHierarchy.getTreeValue().dimension) {\n\t\t\t\t\tnewDimensionHierarchies.push(projectionDimensionHierarchy);\n\t\t\t\t\tfinded = true;\n\t\t\t\t}\n\t\t\t});\n\t\t\tif (!finded) {\n\t\t\t\tconst { members, dimension } = originalDimensionHierarchy.getTreeValue();\n\t\t\t\tconst projectionDimensionHierarchy = DimensionTree.createProxyDimensionTree(originalDimensionHierarchy);\n\t\t\t\tmembers.forEach(member => {\n\t\t\t\t\tlet memberBelongToCells = false;\n\t\t\t\t\tfilteredCellTable.forEach(filteredCell => {\n\t\t\t\t\t\tif (cellBelongsToSpace(filteredCell, { [dimension]: [member] })) {\n\t\t\t\t\t\t\tmemberBelongToCells = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t\tif (!memberBelongToCells) {\n\t\t\t\t\t\tlet has = projectionDimensionHierarchy.getTreeValue().members.indexOf(member) !== -1;\n\t\t\t\t\t\tif (has) {\n\t\t\t\t\t\t\tprojectionDimensionHierarchy.removeProjectionOntoMember(member)\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\tnewDimensionHierarchies.push(projectionDimensionHierarchy);\n\t\t\t}\n\t\t});\n\n\t\treturn new SubCube({\n\t\t\tcellTable: filteredCellTable,\n\t\t\tdimensionHierarchies: newDimensionHierarchies,\n\t\t\toriginalCube: this.originalCube || this,\n\t\t\tpreviousCube: this\n\t\t})\n\t}\n\t/**\n\t * The cube introduces generalization relations\n\t * it's operations on dimension hierarchies\n\t * @public\n\t * @param {string} hierarchy\n\t * @param {string} targetDimension\n\t * @return {Cube}\n\t * */\n\tdrillUp(hierarchy, targetDimension) {\n\t\tconst currentHierarchy = getHierarchy.call(this, hierarchy);\n\t\tif (currentHierarchy && currentHierarchy.hasDimension(targetDimension)) {\n\t\t\tcurrentHierarchy.setActiveDimension(targetDimension);\n\t\t}\n\t\treturn this;\n\t}\n\t/**\n\t * The cube introduced specialization relations\n\t * it's operations on dimension hierarchies\n\t * @public\n\t * @param {string} hierarchy\n\t * @param {string} targetDimension\n\t * @return {Cube}\n\t * */\n\tdrillDown(hierarchy, targetDimension) {\n\t\tconst currentHierarchy = getHierarchy.call(this, hierarchy);\n\t\tif (currentHierarchy && currentHierarchy.hasDimension(targetDimension)) {\n\t\t\tcurrentHierarchy.setActiveDimension(targetDimension);\n\t\t}\n\t\treturn this;\n\t}\n\t/**\n\t * @public\n\t * @return {FactTable} returns facts\n\t * */\n\tgetFacts() {\n\t\treturn denormalize.call(this, this.getCells());\n\t}\n\t/**\n\t * @public\n\t * @param {Object[]} facts\n\t * @return {Cube}\n\t * */\n\taddFacts(facts) {\n\t\tconst newFactTable = new FactTable({facts, primaryKey: this.cellTable.primaryKey});\n\t\tconst cells = newFactTable.getFacts().map(fact => new Cell(fact));\n\t\t[].push.apply(this.getCells(), cells);\n\t\tconst factTable = this.getFacts();\n\t\tSnowflakeBuilder.anotherBuild(factTable, cells, getDimensionTrees.call(this), this.getCells(), this.cellTable.primaryKey);\n\t\treturn this;\n\t}\n\t/**\n\t * @public\n\t * @param {Object[]} facts\n\t * */\n\tremoveFacts(facts) {\n\t\tconst cellTable = this.getCells();\n\t\tconst primaryKey = this.cellTable.primaryKey;\n\t\tconst removedCells = facts.map(fact => {\n\t\t\treturn cellTable.find(cell => cell[primaryKey] === fact[primaryKey])\n\t\t});\n\t\tthis.removeCells(removedCells);\n\t}\n\t/**\n\t * @public\n\t * @return {Cell[]}\n\t * */\n\tgetCells() {\n\t\treturn this.cellTable.cells;\n\t}\n\t/**\n\t * @public\n\t * @param {Cell[]} cells\n\t * */\n\tremoveCells(cells) {\n\t\tSnowflakeBuilder.destroy(this.getCells(), cells, this.dimensionHierarchies, this);\n\t}\n\t/**\n\t * @public\n\t * @param {string} dimension - dimension from which the member will be found\n\t * @return {Member[]} returns members\n\t * */\n\tgetDimensionMembers(dimension) {\n\t\treturn findDimensionTreeByDimension.call(this, dimension).getTreeValue().members;\n\t}\n\t/**\n\t * @public\n\t * @param {string} dimension - dimension in which the member is created\n\t * @param {object?} customMemberOptions - properties for the created member\n\t * @param {object?} rollupCoordinatesData\n\t * @param {object?} drillDownCoordinatesOptions\n\t * @param {object?} cellData\n\t * @throw {InsufficientRollupData}\n\t * */\n\taddDimensionMember(dimension, customMemberOptions = {}, rollupCoordinatesData = {}, drillDownCoordinatesOptions = {}, cellData) {\n\t\t// todo №1, а если члены с такими ключами уже существуют, нужнен варнинг, потому что, после десериализации член исчезнет, если не будут изменены значения ключевых полей\n\t\tif (typeof dimension !== 'string') {\n\t\t\tthrow TypeError(`parameter dimension expects as string: ${dimension}`)\n\t\t}\n\t\tconst rollupCoordinates = {};\n\t\tObject.keys(rollupCoordinatesData).forEach(dimension => {\n\t\t\tconst memberData = rollupCoordinatesData[dimension];\n\t\t\tconst memberList = this.getDimensionMembers(dimension);\n\t\t\tconst dimensionTable = findDimensionTreeByDimension.call(this, dimension).getTreeValue();\n\t\t\tconst { primaryKey } = dimensionTable;\n\t\t\tconst id = memberData[primaryKey];\n\t\t\tconst find = memberList.find(member => {\n\t\t\t\treturn id === dimensionTable.getMemberId(member)\n\t\t\t});\n\t\t\tif (!find) {\n\t\t\t\tthrow new InsufficientRollupData(dimension, id)\n\t\t\t} else {\n\t\t\t\trollupCoordinates[dimension] = find;\n\t\t\t}\n\t\t});\n\t\tconst dimensionTree = findDimensionTreeByDimension.call(this, dimension);\n\t\tconst childDimensionTrees = dimensionTree.getChildTrees();\n\t\tconst dimensionTable = dimensionTree.getTreeValue();\n\t\tconst { foreignKey } = dimensionTable;\n\t\tconst foreignKeysMemberData = {};\n\t\tchildDimensionTrees.forEach(childDimensionTree => {\n\t\t\tconst dimensionTable = childDimensionTree.getTreeValue();\n\t\t\tconst { dimension, foreignKey, primaryKey } = dimensionTable;\n\t\t\tconst member = rollupCoordinatesData[dimension];\n\t\t\tif (!member) {\n\t\t\t\tthrow new InsufficientRollupData(dimension)\n\t\t\t} else {\n\t\t\t\tforeignKeysMemberData[foreignKey] = member[primaryKey];\n\t\t\t}\n\t\t});\n\t\t// todo проверить, что customMemberOptions не содержит внешних ключей\n\t\tconst memberOptions = Object.assign({}, customMemberOptions, foreignKeysMemberData);\n\n\t\tlet saveMember = dimensionTree.createMember(memberOptions);\n\t\tlet saveIdAttribute = foreignKey;\n\t\tdimensionTree.traceUpOrder(tracedDimensionTree => {\n\t\t\tif (dimensionTree !== tracedDimensionTree) {\n\t\t\t\tconst { dimension: parentDimension, foreignKey: parentIdAttribute } = tracedDimensionTree.getTreeValue();\n\t\t\t\tconst drillDownCoordinatesData = { [ saveIdAttribute]: dimensionTable.getMemberId(saveMember) };\n\t\t\t\tObject.assign(drillDownCoordinatesData, drillDownCoordinatesOptions[parentDimension]);\n\t\t\t\tsaveMember = tracedDimensionTree.createMember(drillDownCoordinatesData);\n\t\t\t\tsaveIdAttribute = parentIdAttribute;\n\t\t\t}\n\t\t});\n\t\tthis.fillEmptyCells(cellData);\n\t}\n\t/**\n\t * @public\n\t * @param {string} dimension - dimension from which the member will be removed\n\t * @param {Member} member - the member will be removed\n\t * */\n\tremoveDimensionMember(dimension, member) {\n\t\tconst dimensionTree = findDimensionTreeByDimension.call(this, dimension);\n\t\tconst endToBeRemoved = dimensionTree.removeProjectionOntoMember(member);\n\t\tconst cellTable = this.getCells();\n\t\tconst getRemoveMeasures = (dimension, members) => {\n\t\t\tconst removedCells = [];\n\t\t\tconst dimensionTable = dimensionTree.getDimensionTreeByDimension(dimension).getTreeValue();\n\t\t\tconst foreignKey = dimensionTable.foreignKey;\n\n\t\t\t// todo mapFilter похоже\n\t\t\tcellTable.forEach(cell => {\n\t\t\t\tmembers.forEach(member => {\n\t\t\t\t\tif (cell[foreignKey] == dimensionTable.getMemberId(member)) {\n\t\t\t\t\t\tremovedCells.push(cell)\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t});\n\t\t\treturn removedCells;\n\t\t};\n\t\tObject.keys(endToBeRemoved).map(dimension => {\n\t\t\tconst removedMeasures = getRemoveMeasures(dimension, endToBeRemoved[dimension]);\n\t\t\tremovedMeasures.forEach(cell => {\n\t\t\t\tconst index = cellTable.indexOf(cell);\n\t\t\t\tif (index !== -1) {\n\t\t\t\t\tcellTable.splice(index, 1);\n\t\t\t\t}\n\t\t\t})\n\t\t})\n\t}\n\t/**\n\t * @public\n\t * @param {object|DimensionTree} dimensionHierarchy\n\t * */\n\taddDimensionHierarchy(dimensionHierarchy) {\n\t\tconst dimensionTree = DimensionTree.createDimensionTree(dimensionHierarchy);\n\t\tthis.dimensionHierarchies.push(\n\t\t\tdimensionTree\n\t\t);\n\t\tSnowflakeBuilder.anotherBuildOne(dimensionTree, this.getCells(), this.getCells(), this.getCells(), this.cellTable.primaryKey);\n\t}\n\t/**\n\t * @public\n\t * @param {DimensionTree} dimensionHierarchy\n\t * */\n\tremoveDimensionHierarchy(dimensionHierarchy) {\n\t\t// first remove members\n\t\tSnowflakeBuilder.destroyDimensionTree(this.getCells(), this.getCells(), dimensionHierarchy, this);\n\t\t// then target dimension hierarchy\n\t\tthis.dimensionHierarchies.splice(this.dimensionHierarchies.indexOf(dimensionHierarchy), 1);\n\t}\n\t/**\n\t * @public\n\t * @return {EmptyCell[]}\n\t * */\n\tcreateEmptyCells(cellOptions) {\n\t\tconst emptyCells = [];\n\t\tconst tuples = Cube.cartesian(this);\n\t\ttuples.forEach(combination => {\n\t\t\tconst unique = this.dice(combination).getCells();\n\t\t\tif (!unique.length) {\n\t\t\t\tlet foreignKeysCellData = {};\n\t\t\t\tObject.keys(combination).forEach(dimension => {\n\t\t\t\t\tconst dimensionTable = findDimensionTreeByDimension.call(this, dimension).getTreeValue();\n\t\t\t\t\tconst { foreignKey } = dimensionTable;\n\t\t\t\t\tforeignKeysCellData[foreignKey] = dimensionTable.getMemberId(combination[dimension])\n\t\t\t\t});\n\t\t\t\tconst cellData = {...foreignKeysCellData, ...cellOptions};\n\t\t\t\t// todo нужна правеврка на то, что все свойства присутствуют\n\t\t\t\tconst cell = EmptyCell.createEmptyCell(cellData);\n\t\t\t\temptyCells.push(cell);\n\t\t\t}\n\t\t});\n\t\treturn emptyCells;\n\t}\n\t/**\n\t * @public\n\t * @return {EmptyCell[]}\n\t * */\n\tgetEmptyCells() {\n\t\treturn this.getCells().filter(cell => EmptyCell.isEmptyCell(cell))\n\t}\n\t/**\n\t * @public\n\t * @return {boolean}\n\t * */\n\tisEmptyCell(cell) {\n\t\treturn EmptyCell.isEmptyCell(cell);\n\t}\n\t/**\n\t * @public\n\t * @throw {TypeError}\n\t * */\n\taddEmptyCells(emptyCells) {\n\t\tCube.validateInstance(emptyCells);\n\t\t[].push.apply(this.getCells(), emptyCells);\n\t}\n\t/**\n\t * @public\n\t * Filling method for full size of cube\n\t * @param {object?} customCellOptions - properties for empty cells\n\t * */\n\tfillEmptyCells(customCellOptions = {}) {\n\t\tconst cellOptions = {...this.cellTable.defaultFactOptions, ...customCellOptions};\n\t\tif (!residuals(this).length) {\n\t\t\tconst emptyCells = this.createEmptyCells(cellOptions);\n\t\t\tthis.addEmptyCells(emptyCells);\n\t\t}\n\t}\n\t/**\n\t * @param {EmptyCell[]} emptyCells\n\t * @throw {TypeError}\n\t * */\n\tstatic validateInstance(emptyCells) {\n\t\temptyCells.forEach(emptyCell => {\n\t\t\tif (!(emptyCell instanceof EmptyCell)) {\n\t\t\t\tthrow new TypeError('some item in list of argument is not instances of EmptyCell')\n\t\t\t}\n\t\t});\n\t}\n\t/**\n\t *\n\t * */\n\tisSubCube(){\n\t\treturn this instanceof SubCube;\n\t}\n\t/**\n\t * Cartesian product - list of all possible tuples\n\t * @param {Cube} cube\n\t * @return {Tuple[]}\n\t * */\n\tstatic cartesian(cube) {\n\t\tconst f = (a, b) => [].concat(...a.map(d => {\n\t\t\treturn b.map(e => {\n\t\t\t\treturn [].concat(d, e)\n\t\t\t})\n\t\t}));\n\t\t\n\t\tconst cartesian = (a, b, ...c) => {\n\t\t\treturn b ? cartesian(f(a, b), ...c) : a\n\t\t};\n\t\t\n\t\tconst dimensionsOrder = [];\n\t\t\n\t\tconst set = cube.dimensionHierarchies.map(dimensionTree => dimensionTree.getTreeValue()).map(dimensionTable => {\n\t\t\tdimensionsOrder.push(dimensionTable.dimension);\n\t\t\treturn dimensionTable.members;\n\t\t});\n\t\t\n\t\tconst tupleList = [];\n\t\t\n\t\tlet res;\n\t\tif (set.length) {\n\t\t\tif (set.length > 1) {\n\t\t\t\tres = cartesian.apply(null, set);\n\t\t\t} else {\n\t\t\t\tres = set[0].map(i => [i])\n\t\t\t}\n\t\t\tres.forEach(arr => {\n\t\t\t\tconst item = {};\n\t\t\t\tdimensionsOrder.forEach((dimension, index) => {\n\t\t\t\t\titem[dimension] = arr[index]\n\t\t\t\t});\n\t\t\t\ttupleList.push(new Tuple(item));\n\t\t\t\treturn item;\n\t\t\t});\n\t\t}\n\t\t\n\t\treturn tupleList;\n\t}\n}\n\n/**\n * SubCube is the target cube whose members are members of the source cube.\n * */\nclass SubCube extends Cube {\n\tconstructor({originalCube, previousCube, ...rest}){\n\t\tsuper(rest);\n\t\t/** link for chaining between operations */\n\t\tthis.originalCube = originalCube;\n\t\t/** link for chaining between operations */\n\t\tthis.previousCube = previousCube;\n\t}\n}\n\n/**\n * @this {Cube}\n * @return {DimensionHierarchy}\n * */\nfunction getHierarchy(hierarchy) {\n\treturn this.dimensionHierarchies.find(dimensionHierarchy => {\n\t\treturn dimensionHierarchy.getHierarchy() === hierarchy\n\t});\n}\n/**\n * @this {Cube}\n * @return {DimensionTree}\n * */\nfunction findDimensionTreeByDimension(dimension) {\n\tlet findDimensionTree;\n\tthis.dimensionHierarchies.forEach(dimensionTree => {\n\t\tconst searchedDimensionTree = dimensionTree.getDimensionTreeByDimension(dimension);\n\t\tif (searchedDimensionTree) {\n\t\t\tfindDimensionTree = dimensionTree.getDimensionTreeByDimension(dimension);\n\t\t}\n\t});\n\treturn findDimensionTree;\n}\n/**\n * @this {Cube}\n * @return {DimensionTree[]}\n * */\nfunction getDimensionTrees() {\n\treturn this.dimensionHierarchies.map(dimensionHierarchy => {\n\t\treturn dimensionHierarchy.getDimensionTree\n\t\t\t? dimensionHierarchy.getDimensionTree()\n\t\t\t: dimensionHierarchy\n\t})\n}\n/**\n * @private\n * Get facts from cube\n * */\nfunction denormalize(cells = this.getCells(), forSave = true) {\n\tconst data = SnowflakeBuilder.denormalize(cells, getDimensionTrees.call(this));\n\tif (forSave) {\n\t\tdata.forEach((data, index) => {\n\t\t\tif (cells[index] instanceof EmptyCell) {\n\t\t\t\tdelete data[this.cellTable.primaryKey];\n\t\t\t}\n\t\t})\n\t}\n\treturn data;\n}\n/**\n * @public\n * Residuals - list of tuples, according to which there is more than one member\n * @return {Tuple[]}\n * */\nfunction residuals(cube) {\n\tconst tuples = Cube.cartesian(cube);\n\tconst totalTuples = [];\n\ttuples.forEach(tuple => {\n\t\tconst partFacts = cube.dice(tuple).getFacts();\n\t\tif (partFacts.length > 1) {\n\t\t\ttotalTuples.push(tuple)\n\t\t}\n\t});\n\treturn totalTuples;\n}\n/**\n * Unfilled - list of tuples, in accordance with which there is not a single member\n * @@param {Cube} cube\n * */\nfunction unfilled(cube) {\n\tconst tuples = Cube.cartesian(cube);\n\tconst unfilled = [];\n\ttuples.forEach(tuple => {\n\t\tconst members = this.dice(tuple).getFacts(tuple);\n\t\tif (members.length === 0) {\n\t\t\tunfilled.push(tuple)\n\t\t}\n\t});\n\treturn unfilled;\n}\n\nexport default Cube\n"],"names":["InsufficientRollupData","[object Object]","dimension","id","this","message","NotFoundFactId","name","CreateInstanceException","DimensionException","handleError","error","originalConsole","console","customConsole","log","string","warn","warnOnce","memory","isSimple","value","type","Fact","data","key","hasOwnProperty","Cell","uuidv4","replace","c","r","Math","random","toString","EmptyCell","options","generateId","super","cell","Member","Object","assign","props","primaryKey","isPrototypeOf","Error","memberData","forEach","prop","DEFAULT_TEMPLATE_FOREIGN_KEY","DEFAULT_FACT_ID_PROP","DEFAULT_MEMBER_ID_PROP","InputMember","defaultData","propName","create","DimensionTable","foreignKey","genericId","keyProps","otherProps","members","defaultMemberOptions","keys","indexOf","concat","map","splice","apply","length","member","push","memberOptions","linkProps","reduceId","addMember","reduce","acc","curValue","index","dimensionTable","Tree","getChildTrees","getParentTree","root","traceUpOrder","tracedTree","isRoot","callback","search","tracePostOrder","treeValue","tree","reqursively","parentNode","childTrees","getTreeValue","childTree","has","tracePreOrder","tracedTreeValue","DimensionTree","dimensionTree","level","defineProperties","createDimensionTable","editable","enumerable","dimensionTreeData","validate","dimensions","tracedDimensionTreeValue","newDimensionTree","cloneDimensionTreeWithoutMembers","tracedDimension","getDimensionTreeByDimension","setMemberList","getRoot","searchTreeByTreeValue","newDimensionTreeByMember","projectDrillDown","projectDrillUp","lastTracedMembers","lastTracedDimensionTree","drillDownedMembers","drillDownDimensionMembers","lastTracedMembers2","lastTracedDimensionTree2","b","drillUppedMembers","drillUpDimensionMembers","clone","dimensionTreeValue","clearMemberList","projectionDimensionTree","subtractDimensionTree","endToBeRemovedMember","dimensionProjection","membersProjection","toBeRemovedSpace","tracedDimensionTree","childMembers","childDimension","removeMember","toBeAddedSpace","parentTree","parentMembers","drillDownMembers","parentMember","isExternal","rollUpMembers","childMember","getMemberId","childIdAttributes","createMember","DimensionHierarchy","activeDimension","hierarchy","createDimensionTree","dimensionHierarchy","FactTable","facts","defaultFactOptions","factData","validateFactData","bind","fact","SnowflakeBuilder","factTable","cells","dimensionsTrees","cellTable","factPrimaryKey","anotherBuildOne","processDimension","memberList","childDimensions","existMemberCount","args","entitiesParts","memberListForFilter","mapFilter","makeMemberListLevel","makeMemberList","deleteProps","cellTables","cellTableFiltered","filter","whatIsIt","totalMemberList","countId","entitiesPart","etalon","childIdAttribute","entityPart","startFrom","cache","restoredCache","find","surrogateKey","createKeyFromProps","obj","join","removedCells","dimensionHierarchies","cube","removedCell","travers","removeMembers","restoreCell","dimensionTrees","getFacts","memberCopy","deleteMemberId","dicedCube","dice","getCells","handlers","idValue","handler","handleDimensionTree","Tuple","Space","newSpace","arguments","space","add","targetSpace","otherSpace","Array","prototype","CellTable","cellData","isEmptyCell","Cube","isArray","createDimensionHierarchy","addFacts","set","fixSpace","findDimensionTreeByDimension","call","getDimensionMembers","dimensionHierarchiesLength","projectionDimensionHierarchies","totalSpaces","dimensionTreeProjection","spacesForCells","searchedInTree","current","unionDimensionTree","union","filteredCellTable","cellBelongsToSpace","some","newDimensionHierarchies","originalDimensionHierarchy","finded","projectionDimensionHierarchy","createProxyDimensionTree","memberBelongToCells","filteredCell","removeProjectionOntoMember","SubCube","originalCube","previousCube","targetDimension","currentHierarchy","getHierarchy","hasDimension","setActiveDimension","denormalize","anotherBuild","getDimensionTrees","removeCells","destroy","customMemberOptions","rollupCoordinatesData","drillDownCoordinatesOptions","TypeError","childDimensionTrees","foreignKeysMemberData","childDimensionTree","saveMember","saveIdAttribute","parentDimension","parentIdAttribute","drillDownCoordinatesData","fillEmptyCells","endToBeRemoved","getRemoveMeasures","destroyDimensionTree","cellOptions","emptyCells","cartesian","combination","foreignKeysCellData","createEmptyCell","validateInstance","customCellOptions","residuals","createEmptyCells","addEmptyCells","emptyCell","a","d","e","f","dimensionsOrder","tupleList","res","i","arr","item","rest","findDimensionTree","getDimensionTree","forSave","tuples","totalTuples","tuple"],"mappings":"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"}