{"version":3,"file":"cube.esm.min.js","sources":["../src/errors.js","../src/console.js","../src/Fact.js","../src/Cell.js","../src/EmptyCell.js","../src/Member.js","../src/const.js","../src/InputMember.js","../src/DimensionTable.js","../src/Tree.js","../src/DimensionTree.js","../src/DimensionHierarchy.js","../src/SnowflakeBuilder.js","../src/Tuple.js","../src/Space.js","../node_modules/lodash-es/_freeGlobal.js","../node_modules/lodash-es/_root.js","../node_modules/lodash-es/_Symbol.js","../node_modules/lodash-es/_getRawTag.js","../node_modules/lodash-es/_objectToString.js","../node_modules/lodash-es/_baseGetTag.js","../node_modules/lodash-es/_overArg.js","../node_modules/lodash-es/_getPrototype.js","../node_modules/lodash-es/isObjectLike.js","../node_modules/lodash-es/isPlainObject.js","../src/Cube.js"],"sourcesContent":["export class InsufficientRollupData {\n\tconstructor(dimension, id) {\n\t\tthis.message = `Can't add member, member for rollup dimension: ${dimension} with id: ${id} not found`;\n\t}\n}\n\nexport class NotFoundFactId {\n\tconstructor(name) {\n\t\tthis.message = `In fact data, no property was found with the name: ${name}`\n\t}\n}\n\nexport class NotCompletelySpaceException {\n\tconstructor(dimension) {\n\t\tthis.message = `Not completely defined space for added member, not found member for dimension: \"${dimension}\"`;\n\t}\n}\n\nexport class CantAddMemberRollupException {\n\tconstructor(dimension, id) {\n\t\tthis.message = `Can't add member, rollup dimension: ${dimension} with id: ${id} not found`;\n\t}\n}\n\nexport class DimensionException {\n\tconstructor(dimension) {\n\t\tthis.message = `For the name \"${dimension}\" the dimension is already set`;\n\t}\n}\n\nexport const handleError = error => {\n\terror.message = `[Cube] ${error.message}`\n\tthrow error;\n};\n","const originalConsole = console;\nconst customConsole = {\n\tlog: string => {\n\t\toriginalConsole.log(`[Cube] ${string}`)\n\t},\n\twarn: string => {\n\t\toriginalConsole.warn(`[Cube] ${string}`)\n\t},\n\twarnOnce: (() => {\n\t\tconst memory = {};\n\t\treturn string => {\n\t\t\tif (!memory[string]) {\n\t\t\t\tmemory[string] = true;\n\t\t\t\toriginalConsole.warn(`[Cube] ${string}`)\n\t\t\t}\n\t\t};\n\t})()\n};\nexport default customConsole\n","import {handleError} from './errors.js'\nimport console from './console.js'\n\nconst isSimple = (value) => {\n\tlet type = typeof value;\n\treturn type !== 'object' && type !== 'function' && type !== 'undefined' || value === null\n};\n\nexport default class Fact {\n\t/**\n\t * @throw {NotFoundFactId}\n\t * */\n\tconstructor(data) {\n\t\ttry {\n\t\t\tfor (let key in data) {\n\t\t\t\tif (!data.hasOwnProperty(key)) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tif (isSimple(data[key])) {\n\t\t\t\t\tthis[key] = data[key];\n\t\t\t\t} else {\n\t\t\t\t\tconsole.warn(`[Fact] value of prop \"${key}\" has an unspecified value: ${data[key]}`)\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (error) {\n\t\t\thandleError(error);\n\t\t}\n\t}\n}\n","import Fact from './Fact.js'\n\n/**\n * Cell. A piece of data obtained by defining one element\n * in each dimension of a multidimensional array.\n * The cells of the hypercube can be empty or full.\n *\n * These are aggregated data\n *\n * summary - to describe the values of data in cells\n *\n * each cell is an intersection of all the dimensions of the cube\n * */\nexport default class Cell extends Fact {\n\n}\n","import Cell from './Cell.js'\n\nfunction uuidv4() {\n\treturn 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {\n\t\tlet r = Math.random() * 16 | 0;\n\t\tlet v = c == 'x' ? r : (r & 0x3 | 0x8);\n\t\treturn v.toString(16);\n\t});\n}\n\n/**\n * Empty cells - in the fact table there is no data for them\n * The cell is identified by a tuple\n * */\nexport default class EmptyCell extends Cell {\n\tconstructor(data, options) {\n\t\tif (!data.id) {\n\t\t\tdata.id = EmptyCell.generateId()\n\t\t}\n\t\tsuper(data, options)\n\t}\n\t/**\n\t * @return {EmptyCell}\n\t * */\n\tstatic createEmptyCell(options) {\n\t\treturn new EmptyCell(options)\n\t}\n\t/**\n\t * @param {Cell|{ id: string|number }} cell\n\t * @return {boolean}\n\t * */\n\tstatic isEmptyCell(cell) {\n\t\treturn typeof cell.id === 'string'\n\t}\n\t/**\n\t * @return {string}\n\t * */\n\tstatic generateId() {\n\t\treturn uuidv4()\n\t}\n}\n","/**\n * Element of dimension. Serving to determine the position and description of the data element\n * */\nexport default class Member {\n\tconstructor(data) {\n\t\tObject.assign(this, data);\n\t}\n\tstatic create(id, props, data, primaryKey) {\n\t\tif (!(this === Member || Member.isPrototypeOf(this))) {\n\t\t\tthrow Error('this.constructor must be prototype of Member')\n\t\t}\n\t\tconst memberData = {};\n\t\tmemberData[primaryKey] = id;\n\n\t\tprops.forEach(prop => {\n\t\t\t// исключить идентификатор самой сущности\n\t\t\tif (prop !== primaryKey) {\n\t\t\t\tmemberData[prop] = data[prop]\n\t\t\t}\n\t\t});\n\t\treturn new this(memberData)\n\t}\n}\n","export const DEFAULT_TEMPLATE_FOREIGN_KEY = '%s_id';\nexport const DEFAULT_FACT_ID_PROP = 'id';\nexport const DEFAULT_MEMBER_ID_PROP = 'id';\n","import Member from './Member.js'\n\n/**\n * Introductory elements. Input elements have values that are manually loaded\n * that is, they are not the result of calculating data\n * */\nexport default class InputMember extends Member {\n\tstatic create(id, memberData, data, primaryKey) {\n\t\tconst defaultValue = null;\n\t\tconst defaultData = {};\n\n\t\tmemberData.forEach(propName => {\n\t\t\tdefaultData[propName] = data.hasOwnProperty(propName) ? data[propName] : defaultValue\n\t\t});\n\n\t\treturn super.create(id, memberData, defaultData, primaryKey)\n\t}\n}\n","import Member from './Member.js'\nimport {DEFAULT_MEMBER_ID_PROP, DEFAULT_TEMPLATE_FOREIGN_KEY} from './const.js'\nimport InputMember from './InputMember.js'\n\n/**\n * Dimension is a dimension of a cube. A dimension is a primary organizer of measure and attribute information in a cube\n * A dimension will contain some members organized in some hierarchy or hierarchies containing levels.\n * */\nexport default class DimensionTable {\n\tconstructor({ dimension, foreignKey = DimensionTable.genericId(dimension), primaryKey = DEFAULT_MEMBER_ID_PROP, keyProps, otherProps = [], members = [], defaultMemberOptions = {}}) {\n\t\tif (!dimension || !keyProps) {\n\t\t\tthrow Error('Bad definition DimensionTable, params \\\"dimension\\\" and \\\"keyProps\\\" is required');\n\t\t}\n\t\tif (Object.keys(defaultMemberOptions).indexOf(primaryKey) !== -1) {\n\t\t\tthrow Error('Bad definition DimensionTable, \\\"defaultMemberOptions\\\" must not contain a \\\"primaryKey\\\" property');\n\t\t}\n\t\t/** Name of the dimension */\n\t\tthis.dimension = dimension;\n\t\t/** id name */\n\t\tthis.foreignKey = foreignKey;\n\t\t/** id name */\n\t\tthis.primaryKey = primaryKey;\n\t\t/** List of key names properties of the table belonging to the current dimension */\n\t\tthis.keyProps = [].concat(keyProps);\n\t\t/** List of additional names properties of the table belonging to the current dimension */\n\t\tthis.otherProps = [].concat(otherProps);\n\t\t/** member list */\n\t\tthis.members = members.map(memberData => {\n\t\t\treturn new Member(memberData, this.primaryKey)\n\t\t});\n\t\t/** member default property options */\n\t\tthis.defaultMemberOptions = {...defaultMemberOptions};\n\t}\n\t/**\n\t *\n\t * */\n\tsetMemberList(members) {\n\t\t[].splice.apply(this.members, [0, this.members.length].concat(members))\n\t}\n\t/**\n\t *\n\t * */\n\tclearMemberList() {\n\t\tthis.members = [];\n\t}\n\tgetMemberPrimaryKey(member) {\n\t\treturn member[this.primaryKey]\n\t}\n\tgetMemberForeignKey(member) {\n\t\treturn member[this.foreignKey]\n\t}\n\t/**\n\t * @param {Member} member\n\t * */\n\taddMember(member) {\n\t\tif (this.members.indexOf(member) === -1) {\n\t\t\tthis.members.push(member)\n\t\t} else {\n\t\t\tconsole.log('boo')\n\t\t}\n\t}\n\t/**\n\t * @public\n\t * @param {object} memberOptions\n\t * @param {[]} linkProps\n\t * */\n\tcreateMember(memberOptions = {}, linkProps) {\n\t\t// todo тут нужна проверка на то, что все данные для члена измерения присутствуют\n\t\tconst memberData = {...this.defaultMemberOptions, ...memberOptions};\n\t\tconst { keyProps, otherProps, members, primaryKey } = this;\n\t\tconst keys = keyProps.concat(linkProps).concat(otherProps);\n\t\tconst id = DimensionTable.reduceId(members, primaryKey);\n\t\tconst member = InputMember.create(id, keys, memberData, primaryKey);\n\t\tthis.addMember(member);\n\t\treturn member;\n\t}\n\t/**\n\t * @public\n\t * Method of generating a unique identifier within the selected space\n\t * */\n\tstatic reduceId(members, primaryKey) {\n\t\tif (members.length) {\n\t\t\treturn members.reduce((acc, curValue) => {\n\t\t\t\treturn acc[primaryKey] > curValue[primaryKey] ? acc : curValue;\n\t\t\t}, 0)[primaryKey] + 1\n\t\t} else {\n\t\t\treturn 1;\n\t\t}\n\t}\n\t/**\n\t * @public\n\t * A way to create a name for a property in which a unique identifier will be stored\n\t * */\n\tstatic genericId(dimension) {\n\t\treturn DEFAULT_TEMPLATE_FOREIGN_KEY.replace('%s', dimension);\n\t}\n\tsetMemberId(member, id) {\n\t\tmember[this.primaryKey] = id;\n\t}\n\tdeleteMemberId(member) {\n\t\tdelete member[this.primaryKey]\n\t}\n\t/**\n\t *\n\t * */\n\tremoveMember(member) {\n\t\tconst index = this.members.indexOf(member);\n\t\tif (index === -1) {\n\t\t\tthrow new Error('represented member was not found', member);\n\t\t}\n\t\tthis.members.splice(index, 1);\n\t}\n\tstatic createDimensionTable(dimensionTable) {\n\t\treturn new DimensionTable(dimensionTable)\n\t}\n}\n","/**\n * Tree traversing https://en.wikipedia.org/wiki/Tree_traversal\n * @class Tree\n * @abstract class cannot be instantiated with new\n * */\nexport default class Tree {\n\t/**\n\t * @public\n\t * @abstract\n\t * @return {Object}\n\t * */\n\tgetTreeValue() {\n\t\tthrow 'abstract method'\n\t}\n\t/**\n\t * @public\n\t * @abstract\n\t * @return {Tree|null}\n\t * */\n\tgetParentTree() {\n\t\tthrow 'abstract method'\n\t}\n\t/**\n\t * @public\n\t * @abstract\n\t * @return {Tree[]}\n\t * */\n\tgetChildTrees() {\n\t\tthrow 'abstract method'\n\t}\n\t/**\n\t * @public\n\t * @return {boolean}\n\t * */\n\tisExternal() {\n\t\treturn !this.getChildTrees().length;\n\t}\n\t/**\n\t * @public\n\t * @return {boolean}\n\t * */\n\tisRoot() {\n\t\treturn this.getParentTree() === null;\n\t}\n\t/**\n\t * @public\n\t * Get root for that tree\n\t * @return {Tree}\n\t * */\n\tgetRoot() {\n\t\tlet root = this;\n\t\tthis.traceUpOrder((tracedTreeValue, tracedTree) => {\n\t\t\tif (tracedTree.isRoot()) {\n\t\t\t\troot = tracedTree;\n\t\t\t}\n\t\t});\n\t\treturn root;\n\t}\n\t/**\n\t * @public\n\t * A walk to root from current Tree, the current Tree and root entered to the chain\n\t * @param {function} callback\n\t * */\n\ttraceUpOrder(callback) {\n\t\tconst tree = this;\n\t\tconst parentTree = tree.getParentTree();\n\t\tconst treeValue = tree.getTreeValue();\n\t\tcallback(treeValue, tree);\n\t\tif (parentTree !== null) {\n\t\t\tparentTree.traceUpOrder(callback);\n\t\t}\n\t}\n\t/**\n\t * @public\n\t * A walk in which the children are traversed before their respective parents are traversed\n\t * @param {function} callback\n\t * */\n\ttracePostOrder(callback) {\n\t\tconst tree = this;\n\t\tconst childTrees = tree.getChildTrees();\n\t\tconst treeValue = tree.getTreeValue();\n\t\tif (childTrees.length) {\n\t\t\tchildTrees.forEach(childTree => {\n\t\t\t\tchildTree.tracePostOrder(callback);\n\t\t\t});\n\t\t}\n\t\tcallback(treeValue, tree);\n\t}\n\t/**\n\t * @public\n\t *  A walk in which each parent tree is traversed before its children is called a pre-order walk\n\t * */\n\ttracePreOrder(callback) {\n\t\tconst tree = this;\n\t\tconst childTrees = tree.getChildTrees();\n\t\tconst treeValue = tree.getTreeValue();\n\t\tcallback(treeValue, tree);\n\t\tif (childTrees.length) {\n\t\t\tchildTrees.forEach(childTree => {\n\t\t\t\tchildTree.tracePreOrder(callback);\n\t\t\t});\n\t\t}\n\t}\n}\n","import DimensionTable from './DimensionTable.js'\nimport Tree from './Tree.js'\nimport {DimensionException} from './errors.js'\n/**\n * It defines the relationship of generalization and specialization (roll-up/drill-down)\n * @throws {DimensionException}\n * */\nexport default class DimensionTree extends Tree {\n\tconstructor(dimensionTree) {\n\t\tsuper();\n\n\t\tconst {dimensionTable, level = [], parentNode = null} = dimensionTree;\n\t\t\n\t\tObject.defineProperties(this, {\n\t\t\tdimensionTable: {\n\t\t\t\t/**\n\t\t\t\t * @property\n\t\t\t\t * @name DimensionTree#dimensionTable\n\t\t\t\t * */\n\t\t\t\tvalue: DimensionTable.createDimensionTable(dimensionTable),\n\t\t\t\teditable: false,\n\t\t\t\tenumerable: true\n\t\t\t},\n\t\t\tparentNode: {\n\t\t\t\t/**\n\t\t\t\t * @property {DimensionTree|null}\n\t\t\t\t * @name DimensionTree#parentNode\n\t\t\t\t * */\n\t\t\t\tvalue: parentNode,\n\t\t\t\tenumerable: false,\n\t\t\t\teditable: false\n\t\t\t},\n\t\t\tlevel: {\n\t\t\t\t/**\n\t\t\t\t * @property {DimensionTree[]}\n\t\t\t\t * @name DimensionTree#level\n\t\t\t\t * */\n\t\t\t\tvalue: level.map(dimensionTreeData => {\n\t\t\t\t\treturn new DimensionTree({ ...dimensionTreeData, parentNode: this })\n\t\t\t\t}),\n\t\t\t\tenumerable: true,\n\t\t\t\teditable: false\n\t\t\t}\n\t\t});\n\t\tthis.validateDimensions();\n\t}\n\tvalidateDimensions(){\n\t\tconst dimensions = [];\n\t\tthis.tracePostOrder(tracedDimensionTreeValue => {\n\t\t\tconst {dimension} = tracedDimensionTreeValue;\n\t\t\tif (dimensions.indexOf(dimension) === -1){\n\t\t\t\tdimensions.push(dimension)\n\t\t\t} else {\n\t\t\t\tthrow new DimensionException();\n\t\t\t}\n\t\t})\n\t}\n\tstatic createDimensionTree(dimensionTreeData) {\n\t\t// todo add validation\n\t\treturn new DimensionTree(dimensionTreeData);\n\t}\n\tstatic createProxyDimensionTree(dimensionTree){\n\t\tconst newDimensionTree = dimensionTree.cloneDimensionTreeWithoutMembers();\n\t\tdimensionTree.tracePostOrder(tracedTreeValue => {\n\t\t\tconst { dimension: tracedDimension, members } = tracedTreeValue;\n\t\t\t\n\t\t\tnewDimensionTree\n\t\t\t\t.getDimensionTreeByDimension(tracedDimension)\n\t\t\t\t.getTreeValue()\n\t\t\t\t.setMemberList(members);\n\t\t});\n\t\treturn newDimensionTree;\n\t}\n\t/**\n\t * @public\n\t * @return {DimensionTable}\n\t * */\n\tgetTreeValue() {\n\t\treturn this.dimensionTable;\n\t}\n\t/**\n\t * @public\n\t * @return {DimensionTree|null}\n\t * */\n\tgetParentTree() {\n\t\treturn this.parentNode;\n\t}\n\t/**\n\t * @public\n\t * @return {DimensionTree[]}\n\t * */\n\tgetChildTrees() {\n\t\treturn this.level;\n\t}\n\t/**\n\t * @public\n\t * @param {string} dimension\n\t * @return {DimensionTree|undefined}\n\t * */\n\tgetDimensionTreeByDimension(dimension) {\n\t\tconst root = this.getRoot();\n\t\tlet search = void 0;\n\t\troot.tracePostOrder((dimensionTreeValue, dimensionTree) => {\n\t\t\tif (dimensionTreeValue.dimension === dimension){\n\t\t\t\tsearch = dimensionTree;\n\t\t\t}\n\t\t});\n\t\treturn search;\n\t}\n\t/**\n\t * @public\n\t * @param {Member} member\n\t * @return {DimensionTree|undefined}\n\t * */\n\tcreateProjectionOntoMember(member) {\n\t\t// 1 create copy of hierarchy with empty members\n\t\tconst newDimensionTreeByMember = this.cloneDimensionTreeWithoutMembers();\n\n\t\tthis.projectDrillDown(newDimensionTreeByMember, member);\n\t\tthis.projectDrillUp(newDimensionTreeByMember, member);\n\n\t\treturn newDimensionTreeByMember;\n\t}\n\tprojectDrillDown(dimensionTree, member){\n\t\tthis.projectDrill(dimensionTree, member, \"traceUpOrder\", \"drillDownDimensionMembers\")\n\t}\n\tprojectDrillUp(dimensionTree, member){\n\t\tthis.projectDrill(dimensionTree, member, \"tracePreOrder\", \"drillUpDimensionMembers\")\n\t}\n\tprojectDrill(dimensionTree, member, traceMethodName, method){\n\t\tlet lastTracedMembers;\n\t\tlet lastTracedDimensionTree;\n\t\tthis[traceMethodName]((tracedDimensionTreeValue, tracedDimensionTree) => {\n\t\t\tconst { dimension: tracedDimension } = tracedDimensionTreeValue;\n\n\t\t\tconst drillMembers = tracedDimensionTree == this\n\t\t\t\t? [member]\n\t\t\t\t: lastTracedDimensionTree[method](lastTracedMembers);\n\n\t\t\tdimensionTree\n\t\t\t\t.getDimensionTreeByDimension(tracedDimension)\n\t\t\t\t.getTreeValue()\n\t\t\t\t.setMemberList(drillMembers);\n\n\t\t\tlastTracedMembers = drillMembers;\n\t\t\tlastTracedDimensionTree = tracedDimensionTree;\n\t\t});\n\t}\n\tcloneDimensionTreeWithoutMembers(){\n\t\t// todo new members must be not created here\n\t\tconst clone = new DimensionTree(this.getRoot());\n\t\tclone.tracePostOrder(dimensionTreeValue => {\n\t\t\tdimensionTreeValue.clearMemberList();\n\t\t});\n\t\treturn clone;\n\t}\n\t/**\n\t * @public\n\t * @param {Member} member\n\t * */\n\tremoveProjectionOntoMember(member) {\n\t\t// 1 get projection\n\t\tconst projectionDimensionTree = this.cloneDimensionTreeWithoutMembers();\n\t\tthis.projectDrillDown(projectionDimensionTree, member);\n\n\t\t// 2 subtract projection\n\t\tthis.subtractDimensionTree(projectionDimensionTree);\n\t\t// 3 return first level members of projection\n\t\tconst endToBeRemovedMember = {};\n\n\t\tconst {\n\t\t\tdimension: dimensionProjection,\n\t\t\tmembers: membersProjection\n\t\t} = projectionDimensionTree.getRoot().getTreeValue();\n\n\t\tendToBeRemovedMember[dimensionProjection] = membersProjection;\n\n\t\treturn endToBeRemovedMember;\n\t}\n\t/**\n\t * @private\n\t * @param {DimensionTree} dimensionTree\n\t * */\n\tsubtractDimensionTree(dimensionTree) {\n\t\t// remove intersection\n\t\tconst toBeRemovedSpace = {};\n\n\t\tdimensionTree.tracePostOrder(dimensionTreeValue => {\n\t\t\tconst {dimension, members} = dimensionTreeValue;\n\t\t\ttoBeRemovedSpace[dimension] = members;\n\t\t});\n\n\t\tconst memberList = this.getTreeValue().members;\n\n\t\t// travers down\n\t\tif (memberList.length === 1) {\n\t\t\tthis.tracePreOrder((tracedDimensionTable, tracedDimensionTree) => {\n\t\t\t\tconst {members: childMembers, dimension: childDimension} = tracedDimensionTable;\n\t\t\t\ttoBeRemovedSpace[childDimension] = childMembers;\n\t\t\t})\n\t\t}\n\n\t\t// remove removal space\n\t\tObject.keys(toBeRemovedSpace).forEach(dimension => {\n\t\t\tconst currentDimensionTree = this.getDimensionTreeByDimension(dimension);\n\t\t\tconst dimensionTable = currentDimensionTree.getTreeValue();\n\t\t\ttoBeRemovedSpace[dimension].forEach(member => {\n\t\t\t\tdimensionTable.removeMember(member);\n\t\t\t})\n\t\t});\n\t}\n\tunionDimensionTree(dimensionTree){\n\t\tconst toBeAddedSpace = {};\n\t\tdimensionTree.tracePostOrder(dimensionTreeValue => {\n\t\t\tconst {dimension, members} = dimensionTreeValue;\n\t\t\ttoBeAddedSpace[dimension] = members;\n\t\t});\n\n\t\tObject.keys(toBeAddedSpace).forEach(dimension => {\n\t\t\tconst currentDimensionTree = this.getDimensionTreeByDimension(dimension);\n\t\t\tconst dimensionTable = currentDimensionTree.getTreeValue();\n\t\t\ttoBeAddedSpace[dimension].forEach(member => {\n\t\t\t\tdimensionTable.addMember(member);\n\t\t\t})\n\t\t});\n\t}\n\t/**\n\t * @public\n\t * @param {Member[]} members\n\t * @return {Member[]}\n\t * */\n\tdrillDownDimensionMembers(members = this.getTreeValue().members) {\n\t\tif (this.isRoot()) {\n\t\t\treturn members;\n\t\t}\n\t\tconst parentTree = this.getParentTree();\n\t\tconst parentDimensionTable = parentTree.getTreeValue();\n\t\tconst dimensionTable = this.getTreeValue();\n\t\tconst { members: parentMembers } = parentDimensionTable;\n\t\tconst drillMembers = [];\n\t\tmembers.forEach(member => {\n\t\t\tparentMembers.forEach(parentMember => {\n\t\t\t\tif (dimensionTable.getMemberForeignKey(parentMember) === parentDimensionTable.getMemberPrimaryKey(member)) {\n\t\t\t\t\tif (drillMembers.indexOf(parentMember) === -1) {\n\t\t\t\t\t\tdrillMembers.push(parentMember)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t})\n\t\t});\n\t\treturn drillMembers;\n\t}\n\t/**\n\t * @public\n\t * @this {DimensionTree}\n\t * @param {Member[]} members\n\t * @return {Member[]}\n\t * */\n\tdrillUpDimensionMembers(members = this.getTreeValue().members) {\n\t\tif (this.isExternal()) {\n\t\t\treturn members;\n\t\t}\n\t\tconst childTree = this.getChildTrees()[0]; // for one child always\n\t\tconst childDimensionTable = childTree.getTreeValue();\n\t\tconst { members: childMembers } = childDimensionTable;\n\t\tconst drillMembers = [];\n\t\tmembers.forEach(member => {\n\t\t\tchildMembers.forEach(childMember => {\n\t\t\t\tif (childDimensionTable.getMemberForeignKey(member) === childDimensionTable.getMemberPrimaryKey(childMember)) {\n\t\t\t\t\tif (drillMembers.indexOf(childMember) === -1) {\n\t\t\t\t\t\tdrillMembers.push(childMember)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t})\n\t\t});\n\t\treturn drillMembers;\n\t}\n\t/**\n\t * @public\n\t * @param {object?} memberOptions\n\t * */\n\tcreateMember(memberOptions = {}) {\n\t\tconst dimensionTable = this.getTreeValue();\n\t\tconst childIdAttributes = this.getChildTrees().map(dimensionTree =>\n\t\t\tdimensionTree.getTreeValue().foreignKey\n\t\t);\n\t\tconst linkProps = [];\n\t\tchildIdAttributes.forEach(foreignKey => {\n\t\t\tlinkProps.push(foreignKey)\n\t\t});\n\t\treturn dimensionTable.createMember(memberOptions, linkProps)\n\t}\n}\n","import DimensionTree from './DimensionTree.js'\n\n/**\n * The elements of a dimension can be organized as a hierarchy\n * Hierarchy is a dimension hierarchy of a cube\n * */\nexport default class DimensionHierarchy {\n\tconstructor({ dimensionTree, activeDimension, hierarchy}) {\n\t\tif (!hierarchy) {\n\t\t\tthrow Error('attribute \"hierarchy\" must be defined')\n\t\t}\n\t\tthis.dimensionTree = dimensionTree instanceof DimensionTree\n\t\t\t? dimensionTree\n\t\t\t: DimensionTree.createDimensionTree(dimensionTree);\n\t\tthis.activeDimension = activeDimension || this.dimensionTree.getTreeValue().dimension;\n\t\tthis.hierarchy = hierarchy;\n\t}\n\tgetDimensionTree() {\n\t\treturn this.dimensionTree;\n\t}\n\thasDimension(dimension) {\n\t\treturn !!this.dimensionTree.getDimensionTreeByDimension(dimension);\n\t}\n\tgetActiveDimension() {\n\t\treturn this.activeDimension;\n\t}\n\tsetActiveDimension(activeDimension) {\n\t\tthis.activeDimension = activeDimension;\n\t}\n\tgetHierarchy() {\n\t\treturn this.hierarchy;\n\t}\n\tstatic createDimensionHierarchy(dimensionHierarchy) {\n\t\treturn new DimensionHierarchy(dimensionHierarchy)\n\t}\n}\n","import Member from './Member.js'\n\n/**\n * The main task is to parse the data array into tables\n *\n * is a special case of snowflake dimensionHierarchies\n * where every dimension is represented by one table even if the dimensions has multiple levels\n *\n * snowflaking - normalization process of measurement tables\n * */\nexport default class SnowflakeBuilder {\n\tstatic anotherBuild(factTable, cells, dimensionsTrees, cellTable, factPrimaryKey) {\n\n\t\t// for each dimension\n\t\tdimensionsTrees.forEach(dimensionTree => {\n\t\t\tSnowflakeBuilder.anotherBuildOne(dimensionTree, cells, cellTable, factTable, factPrimaryKey);\n\t\t});\n\t}\n\n\tstatic anotherBuildOne(dimensionTree, cells, cellTable, factTable, factPrimaryKey) {\n\t\t// for each hierarchy and level of dimension\n\t\tdimensionTree.tracePostOrder((dimensionTable, dimensionTree) => {\n\t\t\tSnowflakeBuilder.processDimension(dimensionTree, cells, cellTable, factTable, factPrimaryKey)\n\t\t});\n\t}\n\n\tstatic processDimension(dimensionTree, cells, cellTable, factTable, factPrimaryKey) {\n\t\tconst dimensionTable = dimensionTree.getTreeValue();\n\t\tconst { dimension, keyProps = [], otherProps = [], members: memberList, foreignKey, primaryKey } = dimensionTable;\n\t\tconst childIdAttributes = dimensionTree.getChildTrees().map(dimensionTree => dimensionTree.getTreeValue().foreignKey);\n\t\tconst childDimensions = dimensionTree.getChildTrees().map(dimensionTree => dimensionTree.getTreeValue().dimension);\n\n\t\tlet members;\n\n\t\tconst existMemberCount = memberList.length;\n\t\tconst args = [factPrimaryKey, primaryKey, foreignKey, existMemberCount, factTable, cells, dimension, keyProps, otherProps, cells, cellTable];\n\n\t\tif (!childIdAttributes.length) {\n\t\t\tmembers = SnowflakeBuilder.makeMemberList.apply(null, args);\n\t\t} else {\n\t\t\tlet entitiesParts = [];\n\t\t\tconst dimensionTable = dimensionTree.getDimensionTreeByDimension(childDimensions[0]).getTreeValue();\n\t\t\tconst memberListForFilter = dimensionTable.members;\n\t\t\tentitiesParts = SnowflakeBuilder.mapFilter(childIdAttributes[0], cells, memberListForFilter, dimensionTable);\n\t\t\tmembers = SnowflakeBuilder.makeMemberListLevel.apply(null, args.concat([childIdAttributes, entitiesParts]));\n\t\t}\n\n\t\tfunction deleteProps(fact, props, factPrimaryKey) {\n\t\t\tprops.forEach(prop => {\n\t\t\t\tif (prop !== factPrimaryKey) {\n\t\t\t\t\tdelete fact[prop];\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\t// только после того как список сформирован, удалаять данные из ячеек\n\t\tcells.forEach(cell => {\n\t\t\tdeleteProps(cell, keyProps, factPrimaryKey);\n\t\t\tdeleteProps(cell, otherProps, factPrimaryKey);\n\t\t});\n\n\t\tmembers.forEach(member => {\n\t\t\tdimensionTable.addMember(member)\n\t\t});\n\t}\n\t/**\n\t * Method filter cells by members of a dimension\n\t * @param {string} foreignKey\n\t * @param {Cell[]} cells\n\t * @param {Member[]} memberList\n\t * @param {DimensionTable} dimensionTable\n\t * @private\n\t * @return {Cell[]}\n\t * */\n\tstatic mapFilter(foreignKey, cells, memberList, dimensionTable) {\n\t\tconst cellTables = [];\n\t\t//todo оптимизировать поиск через хеш\n\t\tmemberList.forEach(member => {\n\t\t\tconst cellTableFiltered = cells.filter(cell => {\n\t\t\t\treturn cell[foreignKey] == dimensionTable.getMemberPrimaryKey(member);\n\t\t\t});\n\t\t\tcellTables.push(cellTableFiltered);\n\t\t});\n\t\treturn cellTables;\n\t}\n\t/**\n\t * @private\n\t * */\n\tstatic makeMemberListLevel(factPrimaryKey, primaryKey, foreignKey, existMemberCount, factTable, whatIsIt, dimension, keyProps, otherProps, cells, cellTable, childIdAttributes, entitiesParts) {\n\t\tlet totalMemberList = [];\n\n\t\tlet countId = 0;\n\t\tentitiesParts.forEach(entitiesPart => {\n\t\t\tif (entitiesPart.length) {\n\t\t\t\tconst members = SnowflakeBuilder.makeMemberList(factPrimaryKey, primaryKey, foreignKey, existMemberCount, factTable, entitiesPart, dimension, keyProps, otherProps, cells, cellTable, countId);\n\t\t\t\tcountId = countId + members.length;\n\n\t\t\t\tconst etalon = entitiesPart[0];\n\n\t\t\t\tchildIdAttributes.forEach(childIdAttribute => {\n\n\t\t\t\t\tmembers.forEach(member => {\n\t\t\t\t\t\tmember[childIdAttribute] = etalon[childIdAttribute];\n\t\t\t\t\t\tmember[primaryKey] = (existMemberCount + totalMemberList.length + 1);\n\t\t\t\t\t\ttotalMemberList.push(member)\n\t\t\t\t\t});\n\n\t\t\t\t\tentitiesPart.forEach(entityPart => {\n\t\t\t\t\t\tdelete entityPart[childIdAttribute];\n\t\t\t\t\t})\n\n\t\t\t\t});\n\t\t\t}\n\t\t});\n\n\t\treturn totalMemberList;\n\t}\n\n\t/**\n\t * The method of analyzing the data array and generating new dimension values\n\t *\n\t * @param {object[]} entitiesPart - Data array to the analysis of values for dimension\n\t * @param {number} startFrom\n\t * @param {string} dimension - The dimension for which members will be created\n\t * @param {string[]} keyProps - Names of properties whose values will be used to generate a key that will determine the uniqueness of the new member for dimension\n\t * @param {string[]} otherProps - Names of properties whose values will be appended to the dimension member along with the key properties\n\t * @param {Cell} cells\n\t * @param {Cell[]} cellTable\n\t * @return {[]}\n\t * @private\n\t * */\n\tstatic makeMemberList(\n\t\tfactPrimaryKey,\n\t\tprimaryKey,\n\t\tforeignKey,\n\t\texistMemberCount,\n\t\tfactTable,\n\t\tentitiesPart,\n\t\tdimension,\n\t\tkeyProps = [],\n\t\totherProps = [],\n\t\tcells,\n\t\tcellTable,\n\t\t// It is recommended that the key field be a simple integer because a key value is meaningless\n\t\tstartFrom = 0\n\t) {\n\t\t// соотношение созданных id к ключам\n\t\tconst cache = {};\n\t\tconst restoredCache = {};\n\t\tconst members = [];\n\n\t\t// need restore cache\n\t\tconst existedCells = cellTable.filter(cell => {\n\t\t\treturn cells.indexOf(cell) === -1\n\t\t});\n\t\texistedCells.forEach(cell => {\n\t\t\t// собрать ключ на основе ключевых значений\n\t\t\tconst fact = factTable.find(fact => fact[factPrimaryKey] === cell[factPrimaryKey]);\n\t\t\tconst surrogateKey = SnowflakeBuilder.createKeyFromProps(keyProps, fact);\n\t\t\t// если ключ уникальный создается подсущность и назначается ей присваивается уникальный id (уникальность достигается простым счетчиком)\n\t\t\tif (!(surrogateKey in restoredCache)) {\n\t\t\t\trestoredCache[surrogateKey] = ++startFrom;\n\t\t\t}\n\t\t});\n\n\t\t// создания групп по уникальным ключам\n\t\tentitiesPart.forEach(entityPart => {\n\n\t\t\t// собрать ключ на основе ключевых значений\n\t\t\tconst surrogateKey = SnowflakeBuilder.createKeyFromProps(keyProps, entityPart);\n\n\t\t\t// если ключ уникальный создается подсущность и назначается ей присваивается уникальный id (уникальность достигается простым счетчиком)\n\t\t\tif (!(surrogateKey in cache) && !(surrogateKey in restoredCache)) {\n\t\t\t\tcache[surrogateKey] = ++startFrom;\n\t\t\t}\n\n\t\t\t// оставить в нормальной форме ссылку на id под сущности\n\t\t\tconst id = cache[surrogateKey];\n\t\t\tentityPart[foreignKey] = id;\n\t\t});\n\n\t\tObject.keys(cache).forEach(key => {\n\t\t\tconst id = cache[key];\n\t\t\tconst entityPart = entitiesPart.find(entityPart => entityPart[foreignKey] === id);\n\t\t\tconst member = Member.create(id, [].concat(keyProps).concat(otherProps), entityPart, primaryKey);\n\t\t\tmembers.push(member);\n\t\t});\n\n\t\treturn members;\n\t}\n\n\tstatic createKeyFromProps(props, obj) {\n\t\tconst DIVIDER = ',';\n\n\t\treturn props.map(prop => {\n\t\t\treturn obj[prop]\n\t\t}).join(DIVIDER);\n\t}\n\n\tstatic destroy(cellTable, removedCells, dimensionHierarchies, cube) {\n\t\t// first remove cells\n\t\tremovedCells.forEach(removedCell => {\n\t\t\tconst index = cellTable.indexOf(removedCell);\n\t\t\tif (index !== -1) {\n\t\t\t\tcellTable.splice(index, 1);\n\t\t\t}\n\t\t});\n\t\t// then remove members\n\t\tremovedCells.forEach(fact => {\n\t\t\tdimensionHierarchies.forEach(dimensionTree => {\n\t\t\t\tSnowflakeBuilder.travers([fact], dimensionTree, [SnowflakeBuilder.removeMembers.bind(this, cube, dimensionTree), SnowflakeBuilder.restoreCell]);\n\t\t\t});\n\t\t});\n\t}\n\n\t/**\n\t * Method allows to generate fact tables from cells\n\t * */\n\tstatic denormalize(cellTable, dimensionTrees) {\n\t\tconst facts = [];\n\t\tcellTable.forEach(cell => {\n\t\t\tfacts.push({...cell})\n\t\t});\n\t\tfacts.forEach(fact => {\n\t\t\tdimensionTrees.forEach(dimensionTree => {\n\t\t\t\tSnowflakeBuilder.travers([fact], dimensionTree, [SnowflakeBuilder.restoreCell]);\n\t\t\t});\n\t\t});\n\n\t\treturn facts;\n\t}\n\tstatic restoreCell(member, memberList, dimension, cell, foreignKey, dimensionTable) {\n\t\tconst memberCopy = new Member(member);\n\t\tdimensionTable.deleteMemberId(memberCopy);\n\t\tdelete cell[foreignKey];\n\t\tObject.assign(cell, memberCopy)\n\t}\n\tstatic removeMembers(cube, dimensionTree, member, memberList, dimension, cell, foreignKey) {\n\t\tconst dicedCube = cube.dice({ [dimension]: member });\n\t\tconst dimensionTable = dimensionTree.getDimensionTreeByDimension(dimension).getTreeValue();\n\t\t// last cell was removed at the beginning of the algorithm,\n\t\t// so if the member is no longer used, the projection will be empty\n\t\tif (!dicedCube.getCells().length) {\n\t\t\tdimensionTable.removeMember(member)\n\t\t}\n\t}\n\n\tstatic travers(cellTable, dimensionTree, handlers = () => {}) {\n\t\tconst handleDimensionTree = (dimensionTable, cell) => {\n\t\t\tconst { dimension, members: memberList, foreignKey } = dimensionTable;\n\t\t\tconst idValue = cell[foreignKey];\n\t\t\tconst member = memberList.find(member => {\n\t\t\t\treturn dimensionTable.getMemberPrimaryKey(member) === idValue;\n\t\t\t});\n\t\t\thandlers.forEach(handler => {\n\t\t\t\thandler(member, memberList, dimension, cell, foreignKey, dimensionTable);\n\t\t\t})\n\t\t};\n\t\tcellTable.forEach(cell => {\n\t\t\tdimensionTree.tracePreOrder((tracedDimensionTable, tracedDimensionTree) => {\n\t\t\t\thandleDimensionTree(tracedDimensionTable, cell)\n\t\t\t})\n\t\t});\n\t}\n\n\t/**\n\t * Method allows to delete dimensionTree from cube,\n\t * the cells will be restored, and the members of the measurement are also deleted\n\t * */\n\tstatic destroyDimensionTree(cellTable, removedCells, dimensionTree, cube) {\n\t\tSnowflakeBuilder.travers(cellTable, dimensionTree, [SnowflakeBuilder.removeMembers.bind(this, cube, dimensionTree), SnowflakeBuilder.restoreCell]);\n\t}\n\n}\n","/**\n * The cell is identified by a tuple\n * tuples can uniquely identify every cell in the cube\n * Tuple is an ordered collection of one or more members from different dimensions\n * */\nexport default class Tuple {\n\tconstructor(options) {\n\t\tObject.assign(this, options)\n\t}\n}\n","export default class Space {\n\t/**\n\t *\n\t * */\n\tstatic union() {\n\t\tconst newSpace = {};\n\t\tconst arg = [...arguments];\n\t\targ.forEach(space => {\n\t\t\tSpace.add(newSpace, space);\n\t\t});\n\t\treturn newSpace;\n\t}\n\t/**\n\t *\n\t * */\n\tstatic add(targetSpace, otherSpace) {\n\t\tObject.keys(otherSpace).forEach(key => {\n\t\t\tif (!targetSpace[key]) {\n\t\t\t\ttargetSpace[key] = [];\n\t\t\t}\n\t\t\tArray.prototype.push.apply(targetSpace[key], otherSpace[key])\n\t\t})\n\t}\n}\n","/** Detect free variable `global` from Node.js. */\nvar freeGlobal = typeof global == 'object' && global && global.Object === Object && global;\n\nexport default freeGlobal;\n","import freeGlobal from './_freeGlobal.js';\n\n/** Detect free variable `self`. */\nvar freeSelf = typeof self == 'object' && self && self.Object === Object && self;\n\n/** Used as a reference to the global object. */\nvar root = freeGlobal || freeSelf || Function('return this')();\n\nexport default root;\n","import root from './_root.js';\n\n/** Built-in value references. */\nvar Symbol = root.Symbol;\n\nexport default Symbol;\n","import Symbol from './_Symbol.js';\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar nativeObjectToString = objectProto.toString;\n\n/** Built-in value references. */\nvar symToStringTag = Symbol ? Symbol.toStringTag : undefined;\n\n/**\n * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the raw `toStringTag`.\n */\nfunction getRawTag(value) {\n  var isOwn = hasOwnProperty.call(value, symToStringTag),\n      tag = value[symToStringTag];\n\n  try {\n    value[symToStringTag] = undefined;\n    var unmasked = true;\n  } catch (e) {}\n\n  var result = nativeObjectToString.call(value);\n  if (unmasked) {\n    if (isOwn) {\n      value[symToStringTag] = tag;\n    } else {\n      delete value[symToStringTag];\n    }\n  }\n  return result;\n}\n\nexport default getRawTag;\n","/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar nativeObjectToString = objectProto.toString;\n\n/**\n * Converts `value` to a string using `Object.prototype.toString`.\n *\n * @private\n * @param {*} value The value to convert.\n * @returns {string} Returns the converted string.\n */\nfunction objectToString(value) {\n  return nativeObjectToString.call(value);\n}\n\nexport default objectToString;\n","import Symbol from './_Symbol.js';\nimport getRawTag from './_getRawTag.js';\nimport objectToString from './_objectToString.js';\n\n/** `Object#toString` result references. */\nvar nullTag = '[object Null]',\n    undefinedTag = '[object Undefined]';\n\n/** Built-in value references. */\nvar symToStringTag = Symbol ? Symbol.toStringTag : undefined;\n\n/**\n * The base implementation of `getTag` without fallbacks for buggy environments.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the `toStringTag`.\n */\nfunction baseGetTag(value) {\n  if (value == null) {\n    return value === undefined ? undefinedTag : nullTag;\n  }\n  return (symToStringTag && symToStringTag in Object(value))\n    ? getRawTag(value)\n    : objectToString(value);\n}\n\nexport default baseGetTag;\n","/**\n * Creates a unary function that invokes `func` with its argument transformed.\n *\n * @private\n * @param {Function} func The function to wrap.\n * @param {Function} transform The argument transform.\n * @returns {Function} Returns the new function.\n */\nfunction overArg(func, transform) {\n  return function(arg) {\n    return func(transform(arg));\n  };\n}\n\nexport default overArg;\n","import overArg from './_overArg.js';\n\n/** Built-in value references. */\nvar getPrototype = overArg(Object.getPrototypeOf, Object);\n\nexport default getPrototype;\n","/**\n * Checks if `value` is object-like. A value is object-like if it's not `null`\n * and has a `typeof` result of \"object\".\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n * @example\n *\n * _.isObjectLike({});\n * // => true\n *\n * _.isObjectLike([1, 2, 3]);\n * // => true\n *\n * _.isObjectLike(_.noop);\n * // => false\n *\n * _.isObjectLike(null);\n * // => false\n */\nfunction isObjectLike(value) {\n  return value != null && typeof value == 'object';\n}\n\nexport default isObjectLike;\n","import baseGetTag from './_baseGetTag.js';\nimport getPrototype from './_getPrototype.js';\nimport isObjectLike from './isObjectLike.js';\n\n/** `Object#toString` result references. */\nvar objectTag = '[object Object]';\n\n/** Used for built-in method references. */\nvar funcProto = Function.prototype,\n    objectProto = Object.prototype;\n\n/** Used to resolve the decompiled source of functions. */\nvar funcToString = funcProto.toString;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/** Used to infer the `Object` constructor. */\nvar objectCtorString = funcToString.call(Object);\n\n/**\n * Checks if `value` is a plain object, that is, an object created by the\n * `Object` constructor or one with a `[[Prototype]]` of `null`.\n *\n * @static\n * @memberOf _\n * @since 0.8.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.\n * @example\n *\n * function Foo() {\n *   this.a = 1;\n * }\n *\n * _.isPlainObject(new Foo);\n * // => false\n *\n * _.isPlainObject([1, 2, 3]);\n * // => false\n *\n * _.isPlainObject({ 'x': 0, 'y': 0 });\n * // => true\n *\n * _.isPlainObject(Object.create(null));\n * // => true\n */\nfunction isPlainObject(value) {\n  if (!isObjectLike(value) || baseGetTag(value) != objectTag) {\n    return false;\n  }\n  var proto = getPrototype(value);\n  if (proto === null) {\n    return true;\n  }\n  var Ctor = hasOwnProperty.call(proto, 'constructor') && proto.constructor;\n  return typeof Ctor == 'function' && Ctor instanceof Ctor &&\n    funcToString.call(Ctor) == objectCtorString;\n}\n\nexport default isPlainObject;\n","import EmptyCell from './EmptyCell.js'\nimport Member from './Member.js'\nimport DimensionTree from './DimensionTree.js'\nimport DimensionHierarchy from './DimensionHierarchy.js'\nimport DimensionTable from './DimensionTable.js'\nimport {\n\tInsufficientRollupData,\n} from './errors.js';\nimport SnowflakeBuilder from './SnowflakeBuilder.js'\nimport console from './console.js'\nimport Tuple from './Tuple.js'\nimport Space from './Space.js'\nimport Cell from './Cell.js'\nimport { DEFAULT_FACT_ID_PROP } from './const.js'\nimport isPlainObject from \"./../node_modules/lodash-es/isPlainObject.js\"\nimport {NotFoundFactId} from \"./errors.js\";\n\n/**\n * It a means to retrieve data\n *\n * Base class for normalizing a denormalized data array\n * and analyzing query according to a given scheme\n *\n * */\nclass Cube {\n\t/**\n\t * @param {object | Cube} cube\n\t * @throw {TypeError}\n\t * */\n\tconstructor(cube = {}) {\n\t\tif (!(isPlainObject(cube) || cube instanceof Cube)){\n\t\t\tthrow TypeError('The argument must be plain object or instance of Cube')\n\t\t}\n\t\tlet {\n\t\t\tdimensionHierarchies = [],\n\t\t\tcellTable = [],\n\t\t\tdefaultFactOptions = {},\n\t\t\tfactPrimaryKey = DEFAULT_FACT_ID_PROP\n\t\t} = cube;\n\n\t\tthis.defaultFactOptions = defaultFactOptions;\n\t\tthis.factPrimaryKey = factPrimaryKey;\n\n\t\tthis.dimensionHierarchies = dimensionHierarchies.map(dimensionHierarchy => {\n\t\t\t// duck\n\t\t\tif (dimensionHierarchy.hierarchy) {\n\t\t\t\tif (dimensionHierarchy instanceof DimensionHierarchy) {\n\t\t\t\t\treturn dimensionHierarchy;\n\t\t\t\t} else {\n\t\t\t\t\treturn DimensionHierarchy.createDimensionHierarchy(dimensionHierarchy);\n\t\t\t\t}\n\t\t\t} else if (dimensionHierarchy.dimensionTable) {\n\t\t\t\tif ( dimensionHierarchy instanceof DimensionTree ){\n\t\t\t\t\treturn dimensionHierarchy;\n\t\t\t\t} else {\n\t\t\t\t\treturn DimensionTree.createDimensionTree(dimensionHierarchy);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (dimensionHierarchy instanceof DimensionTable) {\n\t\t\t\t\treturn dimensionHierarchy;\n\t\t\t\t} else {\n\t\t\t\t\treturn DimensionTable.createDimensionTable(dimensionHierarchy);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\tthis.cellTable = cellTable.map(cellData => {\n\t\t\tif (cellData instanceof Cell) {\n\t\t\t\treturn cellData\n\t\t\t} else {\n\t\t\t\treturn EmptyCell.isEmptyCell(cellData) ? new EmptyCell(cellData) : new Cell(cellData)\n\t\t\t}\n\t\t});\n\n\t\t// const residuals = residuals(this);\n\t\t// const count = residuals.length;\n\t\t// if (count > 0) {\n\t\t// \tconsole.warn('Fact table has residuals', residuals)\n\t\t// }\n\t}\n\t/**\n\t * is the act of picking a rectangular subset of a cube by choosing a single value\n\t * for one of its dimensions, creating a new cube with one fewer dimension.\n\t * @public\n\t * @param {string} dimension\n\t * @param {Member} member\n\t * @return {Cube}\n\t * */\n\tslice(dimension, member) {\n\t\treturn this.dice({ [dimension]: member })\n\t}\n\t/**\n\t * @public\n\t * @param {object} set\n\t * @return {Cube}\n\t * @throw {TypeError}\n\t * @throw {RangeError}\n\t * */\n\tdice(set) {\n\t\tif (!(isPlainObject(set) || set instanceof Tuple)){\n\t\t\tthrow TypeError(\"The argument must be a plain object\")\n\t\t}\n\t\t\n\t\t// always work with arrays as value\n\t\tconst toMultiset = (value) => {\n\t\t\treturn Array.isArray(value) ? value : [value];\n\t\t};\n\t\t\n\t\t// change member data to original member objects\n\t\tconst toOriginal = (membersData, dimension) => {\n\t\t\tconst dimensionTree = getDimensionTreeByDimension.call(this, dimension);\n\t\t\tconst dimensionTable = dimensionTree.getTreeValue();\n\t\t\tconst members = dimensionTable.members;\n\t\t\t//replace memberData with original members\n\t\t\tmembersData.forEach((memberData, index) => {\n\t\t\t\tlet member = members.find(member => dimensionTable.getMemberPrimaryKey(member) === dimensionTable.getMemberPrimaryKey(memberData));\n\t\t\t\tif (!member) {\n\t\t\t\t\tthrow RangeError(`Not found member by id ${dimensionTable.getMemberPrimaryKey(member)}`)\n\t\t\t\t}\n\t\t\t\tif (membersData instanceof Member){\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tmembersData[index] = member;\n\t\t\t});\n\t\t\treturn membersData;\n\t\t};\n\t\t\n\t\tconst originalMultiset = {};\n\t\tObject.keys(set).forEach((dimension) => {\n\t\t\tlet value = set[dimension];\n\t\t\tvalue = toMultiset(value);\n\t\t\tvalue = toOriginal(value, dimension);\n\t\t\toriginalMultiset[dimension] = value;\n\t\t});\n\t\t\n\t\tconst dimensions = Object.keys(originalMultiset);\n\t\t\n\t\t// 1 make one projection on to member\n\t\tconst dimensionHierarchiesLength = this.dimensionHierarchies.length;\n\t\tif (dimensions.length > dimensionHierarchiesLength) {\n\t\t\tthrow Error(`Set must have a size not more than ${dimensionHierarchiesLength} dimensions`)\n\t\t}\n\n\t\tconst projectionDimensionHierarchies = [];\n\n\t\t// for every dimension in set\n\t\tconst totalSpaces = dimensions.map(dimension => {\n\n\t\t\tlet dimensionTreeProjection;\n\t\t\tconst members = originalMultiset[dimension];\n\t\t\t// ищется его расширенная версия для каждого члена\n\t\t\tconst spacesForCells = members.map(member => {\n\n\t\t\t\tlet searchedInTree = getDimensionTreeByDimension.call(this, dimension);\n\n\t\t\t\tconst current = searchedInTree.cloneDimensionTreeWithoutMembers();\n\n\t\t\t\tsearchedInTree.projectDrillDown(current, member);\n\t\t\t\tsearchedInTree.projectDrillUp(current, member);\n\n\t\t\t\tif (dimensionTreeProjection){\n\t\t\t\t\tdimensionTreeProjection.unionDimensionTree(current)\n\t\t\t\t} else {\n\t\t\t\t\tdimensionTreeProjection = current;\n\t\t\t\t}\n\t\t\t\tconst {\n\t\t\t\t\tdimension: dimensionProjection,\n\t\t\t\t\tmembers: membersProjection\n\t\t\t\t} = dimensionTreeProjection.getRoot().getTreeValue();\n\n\t\t\t\treturn { [dimensionProjection]: membersProjection };\n\t\t\t});\n\n\t\t\tif (dimensionTreeProjection){\n\t\t\t\tprojectionDimensionHierarchies.push(dimensionTreeProjection);\n\t\t\t}\n\n\t\t\t// после чего эти расширенные версии объекдиняются\n\t\t\tconst totalSpace = Space.union(...spacesForCells);\n\n\t\t\treturn totalSpace;\n\t\t});\n\n\t\t// фильтрация продолжается\n\t\tlet filteredCellTable = this.getCells();\n\n\t\tconst cellBelongsToSpace = (cell, space) => {\n\t\t\tconst somePropOfCellNotBelongToSpace = Object.keys(space).some(dimension => {\n\t\t\t\tconst members = space[dimension];\n\t\t\t\tconst { foreignKey, primaryKey } = getDimensionTreeByDimension.call(this, dimension).getTreeValue();\n\t\t\t\tconst finded = members.find(member => {\n\t\t\t\t\treturn member[primaryKey] === cell[foreignKey]\n\t\t\t\t});\n\t\t\t\treturn !finded;\n\t\t\t});\n\t\t\treturn !somePropOfCellNotBelongToSpace;\n\t\t};\n\n\t\ttotalSpaces.forEach(space => {\n\t\t\t// и ищутся те ячейки, которые принадлежат получившейся области\n\t\t\tfilteredCellTable = filteredCellTable.filter(cell => {\n\t\t\t\treturn cellBelongsToSpace(cell, space)\n\t\t\t});\n\t\t});\n\n\t\t// 2 create new list of dimensionHierarchies\n\t\tconst newDimensionHierarchies = [];\n\t\tthis.dimensionHierarchies.forEach(originalDimensionHierarchy => {\n\t\t\tlet finded = false;\n\t\t\tprojectionDimensionHierarchies.forEach(projectionDimensionHierarchy => {\n\t\t\t\tif (originalDimensionHierarchy.getTreeValue().dimension === projectionDimensionHierarchy.getTreeValue().dimension) {\n\t\t\t\t\tnewDimensionHierarchies.push(projectionDimensionHierarchy);\n\t\t\t\t\tfinded = true;\n\t\t\t\t}\n\t\t\t});\n\t\t\tif (!finded) {\n\t\t\t\tconst { members, dimension } = originalDimensionHierarchy.getTreeValue();\n\t\t\t\tconst projectionDimensionHierarchy = DimensionTree.createProxyDimensionTree(originalDimensionHierarchy);\n\t\t\t\tmembers.forEach(member => {\n\t\t\t\t\tlet memberBelongToCells = false;\n\t\t\t\t\tfilteredCellTable.forEach(filteredCell => {\n\t\t\t\t\t\tif (cellBelongsToSpace(filteredCell, { [dimension]: [member] })) {\n\t\t\t\t\t\t\tmemberBelongToCells = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t\tif (!memberBelongToCells) {\n\t\t\t\t\t\tlet has = projectionDimensionHierarchy.getTreeValue().members.indexOf(member) !== -1;\n\t\t\t\t\t\tif (has) {\n\t\t\t\t\t\t\tprojectionDimensionHierarchy.removeProjectionOntoMember(member)\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\tnewDimensionHierarchies.push(projectionDimensionHierarchy);\n\t\t\t}\n\t\t});\n\n\t\treturn new SubCube({\n\t\t\tcellTable: filteredCellTable,\n\t\t\tdimensionHierarchies: newDimensionHierarchies,\n\t\t\toriginalCube: this.originalCube || this,\n\t\t\tpreviousCube: this\n\t\t})\n\t}\n\t/**\n\t * The cube introduces generalization relations\n\t * it's operations on dimension hierarchies\n\t * @public\n\t * @param {string} hierarchy\n\t * @param {string} targetDimension\n\t * @return {Cube}\n\t * */\n\tdrillUp(hierarchy, targetDimension) {\n\t\tconst currentHierarchy = getHierarchy.call(this, hierarchy);\n\t\tif (currentHierarchy && currentHierarchy.hasDimension(targetDimension)) {\n\t\t\tcurrentHierarchy.setActiveDimension(targetDimension);\n\t\t}\n\t\treturn this;\n\t}\n\t/**\n\t * The cube introduced specialization relations\n\t * it's operations on dimension hierarchies\n\t * @public\n\t * @param {string} hierarchy\n\t * @param {string} targetDimension\n\t * @return {Cube}\n\t * */\n\tdrillDown(hierarchy, targetDimension) {\n\t\tconst currentHierarchy = getHierarchy.call(this, hierarchy);\n\t\tif (currentHierarchy && currentHierarchy.hasDimension(targetDimension)) {\n\t\t\tcurrentHierarchy.setActiveDimension(targetDimension);\n\t\t}\n\t\treturn this;\n\t}\n\t/**\n\t * @public\n\t * @return {Fact[]} returns facts\n\t * */\n\tgetFacts() {\n\t\treturn denormalize.call(this, this.getCells());\n\t}\n\t/**\n\t * @public\n\t * @param {Object[]} facts\n\t * @throw {TypeError}\n\t * @return {Cube}\n\t * */\n\taddFacts(facts) {\n\t\tif (!Array.isArray(facts)){\n\t\t\tthrow TypeError('The argument must be instance of Array')\n\t\t}\n\t\tfacts.forEach(validateFactData.bind(null, this.factPrimaryKey));\n\t\tconst cells = facts.map(fact => new Cell(fact));\n\t\t[].push.apply(this.getCells(), cells);\n\t\tconst factTable = this.getFacts();\n\t\tSnowflakeBuilder.anotherBuild(factTable, cells, getDimensionTrees.call(this), this.getCells(), this.factPrimaryKey);\n\t\treturn this;\n\t}\n\t/**\n\t * @public\n\t * @param {Object[]} facts\n\t * @throw {TypeError}\n\t * */\n\tremoveFacts(facts) {\n\t\tif (!Array.isArray(facts)){\n\t\t\tthrow TypeError('The argument must be instance of Array')\n\t\t}\n\t\tconst cellTable = this.getCells();\n\t\tconst factPrimaryKey = this.factPrimaryKey;\n\t\tconst removedCells = facts.map(fact => {\n\t\t\treturn cellTable.find(cell => cell[factPrimaryKey] === fact[factPrimaryKey])\n\t\t});\n\t\tthis.removeCells(removedCells);\n\t}\n\t/**\n\t * @public\n\t * @return {Cell[]}\n\t * */\n\tgetCells() {\n\t\treturn this.cellTable;\n\t}\n\t/**\n\t * @public\n\t * @param {Cell[]} cells\n\t * @throw {TypeError}\n\t * */\n\tremoveCells(cells) {\n\t\tif (!Array.isArray(cells)){\n\t\t\tthrow TypeError('The argument must be instance of Array')\n\t\t}\n\t\tcells.forEach((cell) => {\n\t\t\tif (!(cell instanceof Cell)){\n\t\t\t\tthrow TypeError('The list of cells must contain only instances of Cell and EmptyCell')\n\t\t\t}\n\t\t});\n\t\tSnowflakeBuilder.destroy(this.getCells(), cells, this.dimensionHierarchies, this);\n\t}\n\t/**\n\t * @public\n\t * @param {string} dimension - dimension from which the member will be found\n\t * @return {Member[]} returns members\n\t * @throw {TypeError}\n\t * */\n\tgetDimensionMembers(dimension) {\n\t\tif (!(typeof dimension === 'string')){\n\t\t\tthrow TypeError('The first argument must be string')\n\t\t}\n\t\tconst dimensionTree = getDimensionTreeByDimension.call(this, dimension);\n\t\treturn dimensionTree.getTreeValue().members;\n\t}\n\t/**\n\t * @public\n\t * @param {string} dimension - dimension in which the member is created\n\t * @param {object?} customMemberOptions - properties for the created member\n\t * @param {object?} rollupCoordinatesData\n\t * @param {object?} drillDownCoordinatesOptions\n\t * @param {object?} cellData\n\t * @throw {InsufficientRollupData}\n\t * */\n\taddDimensionMember(dimension, customMemberOptions = {}, rollupCoordinatesData = {}, drillDownCoordinatesOptions = {}, cellData = {}) {\n\t\tif (!(typeof dimension === 'string')){\n\t\t\tthrow TypeError('The first argument must be instance of string')\n\t\t}\n\t\tif (!(\n\t\t\tisPlainObject(customMemberOptions)\n\t\t\t&& isPlainObject(rollupCoordinatesData)\n\t\t\t&& isPlainObject(drillDownCoordinatesOptions)\n\t\t\t&& isPlainObject(cellData)\n\t\t)){\n\t\t\tthrow TypeError('The arguments after the first must be plain objects')\n\t\t}\n\t\t\n\t\t// todo №1, а если члены с такими ключами уже существуют, нужнен варнинг, потому что, после десериализации член исчезнет, если не будут изменены значения ключевых полей\n\t\tconst rollupCoordinates = {};\n\t\tObject.keys(rollupCoordinatesData).forEach(dimension => {\n\t\t\tconst memberData = rollupCoordinatesData[dimension];\n\t\t\tconst memberList = this.getDimensionMembers(dimension);\n\t\t\tconst dimensionTable = getDimensionTreeByDimension.call(this, dimension).getTreeValue();\n\t\t\tconst { primaryKey } = dimensionTable;\n\t\t\tconst id = memberData[primaryKey];\n\t\t\tconst find = memberList.find(member => {\n\t\t\t\treturn id === dimensionTable.getMemberPrimaryKey(member)\n\t\t\t});\n\t\t\tif (!find) {\n\t\t\t\tthrow new InsufficientRollupData(dimension, id)\n\t\t\t} else {\n\t\t\t\trollupCoordinates[dimension] = find;\n\t\t\t}\n\t\t});\n\t\tconst dimensionTree = getDimensionTreeByDimension.call(this, dimension);\n\t\tconst childDimensionTrees = dimensionTree.getChildTrees();\n\t\tconst dimensionTable = dimensionTree.getTreeValue();\n\t\tconst { foreignKey } = dimensionTable;\n\t\tconst foreignKeysMemberData = {};\n\t\tchildDimensionTrees.forEach(childDimensionTree => {\n\t\t\tconst dimensionTable = childDimensionTree.getTreeValue();\n\t\t\tconst { dimension, foreignKey, primaryKey } = dimensionTable;\n\t\t\tconst member = rollupCoordinatesData[dimension];\n\t\t\tif (!member) {\n\t\t\t\tthrow new InsufficientRollupData(dimension)\n\t\t\t} else {\n\t\t\t\tforeignKeysMemberData[foreignKey] = member[primaryKey];\n\t\t\t}\n\t\t});\n\t\t// todo проверить, что customMemberOptions не содержит внешних ключей\n\t\tconst memberOptions = Object.assign({}, customMemberOptions, foreignKeysMemberData);\n\n\t\tlet saveMember = dimensionTree.createMember(memberOptions);\n\t\tlet saveIdAttribute = foreignKey;\n\t\tdimensionTree.traceUpOrder((tracedDimensionTable, tracedDimensionTree) => {\n\t\t\tif (dimensionTree !== tracedDimensionTree) {\n\t\t\t\tconst { dimension: parentDimension, foreignKey: parentIdAttribute } = tracedDimensionTable;\n\t\t\t\tconst drillDownCoordinatesData = { [ saveIdAttribute]: dimensionTable.getMemberPrimaryKey(saveMember) };\n\t\t\t\tObject.assign(drillDownCoordinatesData, drillDownCoordinatesOptions[parentDimension]);\n\t\t\t\tsaveMember = tracedDimensionTree.createMember(drillDownCoordinatesData);\n\t\t\t\tsaveIdAttribute = parentIdAttribute;\n\t\t\t}\n\t\t});\n\t\tthis.fillEmptyCells(cellData);\n\t}\n\t/**\n\t * @public\n\t * @param {string} dimension - dimension from which the member will be removed\n\t * @param {Member} member - the member will be removed\n\t * throw {TypeError}\n\t * */\n\tremoveDimensionMember(dimension, member) {\n\t\tif (!(typeof dimension === 'string')){\n\t\t\tthrow TypeError('The first argument must be instance of string')\n\t\t}\n\t\tif (!(member instanceof Member)){\n\t\t\tthrow TypeError('The second argument must be instance of Member')\n\t\t}\n\t\tconst dimensionTree = getDimensionTreeByDimension.call(this, dimension);\n\t\tconst endToBeRemoved = dimensionTree.removeProjectionOntoMember(member);\n\t\tconst cellTable = this.getCells();\n\t\tconst getRemoveMeasures = (dimension, members) => {\n\t\t\tconst removedCells = [];\n\t\t\tconst dimensionTable = dimensionTree.getDimensionTreeByDimension(dimension).getTreeValue();\n\t\t\tconst foreignKey = dimensionTable.foreignKey;\n\n\t\t\t// todo mapFilter похоже\n\t\t\tcellTable.forEach(cell => {\n\t\t\t\tmembers.forEach(member => {\n\t\t\t\t\tif (cell[foreignKey] == dimensionTable.getMemberPrimaryKey(member)) {\n\t\t\t\t\t\tremovedCells.push(cell)\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t\t});\n\t\t\treturn removedCells;\n\t\t};\n\t\tObject.keys(endToBeRemoved).map(dimension => {\n\t\t\tconst removedMeasures = getRemoveMeasures(dimension, endToBeRemoved[dimension]);\n\t\t\tremovedMeasures.forEach(cell => {\n\t\t\t\tconst index = cellTable.indexOf(cell);\n\t\t\t\tif (index !== -1) {\n\t\t\t\t\tcellTable.splice(index, 1);\n\t\t\t\t}\n\t\t\t})\n\t\t})\n\t}\n\t/**\n\t * @public\n\t * @param {object|DimensionTree} dimensionHierarchy\n\t * @throw {TypeError}\n\t * */\n\taddDimensionHierarchy(dimensionHierarchy) {\n\t\tconst dimensionTree = DimensionTree.createDimensionTree(dimensionHierarchy);\n\t\tthis.dimensionHierarchies.push(\n\t\t\tdimensionTree\n\t\t);\n\t\tSnowflakeBuilder.anotherBuildOne(dimensionTree, this.getCells(), this.getCells(), this.getCells(), this.factPrimaryKey);\n\t}\n\t/**\n\t * @public\n\t * @param {DimensionTree} dimensionHierarchy\n\t * */\n\tremoveDimensionHierarchy(dimensionHierarchy) {\n\t\tif (!(dimensionHierarchy instanceof DimensionTree)){\n\t\t\tthrow TypeError('The argument must be instance of DimensionTree')\n\t\t}\n\t\t// first remove members\n\t\tSnowflakeBuilder.destroyDimensionTree(this.getCells(), this.getCells(), dimensionHierarchy, this);\n\t\t// then target dimension hierarchy\n\t\tthis.dimensionHierarchies.splice(this.dimensionHierarchies.indexOf(dimensionHierarchy), 1);\n\t}\n\t/**\n\t * @public\n\t * @return {EmptyCell[]}\n\t * @throw {TypeError}\n\t * */\n\tcreateEmptyCells(cellOptions = {}) {\n\t\tif (!isPlainObject(cellOptions)){\n\t\t\tthrow TypeError('Cell option argument must be a pure object')\n\t\t}\n\t\tconst emptyCells = [];\n\t\tconst tuples = Cube.cartesian(this);\n\t\ttuples.forEach(tuple => {\n\t\t\tconst unique = this.dice(tuple).getCells();\n\t\t\tif (!unique.length) {\n\t\t\t\tconst foreignKeysCellData = {};\n\t\t\t\tObject.keys(tuple).forEach(dimension => {\n\t\t\t\t\tconst dimensionTree = getDimensionTreeByDimension.call(this, dimension);\n\t\t\t\t\tconst dimensionTable = dimensionTree.getTreeValue();\n\t\t\t\t\tconst { foreignKey } = dimensionTable;\n\t\t\t\t\tforeignKeysCellData[foreignKey] = dimensionTable.getMemberPrimaryKey(tuple[dimension])\n\t\t\t\t});\n\t\t\t\tconst cellData = {\n\t\t\t\t\t...this.defaultFactOptions,\n\t\t\t\t\t...cellOptions,\n\t\t\t\t\t...foreignKeysCellData,\n\t\t\t\t};\n\t\t\t\t// todo нужна правеврка на то, что все свойства присутствуют, для этого нужна инф-ия о именах таких полей в схеме\n\t\t\t\tconst cell = EmptyCell.createEmptyCell(cellData);\n\t\t\t\temptyCells.push(cell);\n\t\t\t}\n\t\t});\n\t\treturn emptyCells;\n\t}\n\t/**\n\t * @public\n\t * @return {EmptyCell[]}\n\t * */\n\tgetEmptyCells() {\n\t\treturn this.getCells().filter(cell => EmptyCell.isEmptyCell(cell))\n\t}\n\t/**\n\t * @public\n\t * @param {Cell} cell\n\t * @return {boolean}\n\t * */\n\tisEmptyCell(cell) {\n\t\treturn EmptyCell.isEmptyCell(cell);\n\t}\n\t/**\n\t * @public\n\t * @param {EmptyCell[]} emptyCells\n\t * @throw {TypeError}\n\t * */\n\taddEmptyCells(emptyCells) {\n\t\tif (!Array.isArray(emptyCells)){\n\t\t\tthrow TypeError('The argument must be instance of Array')\n\t\t}\n\t\temptyCells.forEach((emptyCell, index) => {\n\t\t\tif (!this.isEmptyCell(emptyCell)) {\n\t\t\t\tthrow TypeError(`Some item in list of argument is not instances of EmptyCell, index: ${index}`)\n\t\t\t}\n\t\t});\n\t\t[].push.apply(this.getCells(), emptyCells);\n\t}\n\t/**\n\t * @public\n\t * Filling method for full size of cube\n\t * @param {object?} cellOptions - properties for empty cells\n\t * */\n\tfillEmptyCells(cellOptions) {\n\t\t// todo why here residuals? add test for that\n\t\tif (!residuals(this).length) {\n\t\t\tconst emptyCells = this.createEmptyCells(cellOptions);\n\t\t\tthis.addEmptyCells(emptyCells);\n\t\t}\n\t}\n\t/**\n\t * Check that the argument is an instance of SubCube\n\t * @return {boolean}\n\t * */\n\tisSubCube(){\n\t\treturn this instanceof SubCube;\n\t}\n\t/**\n\t * Cartesian product - list of all possible tuples\n\t * @param {Cube} cube\n\t * @return {Tuple[]}\n\t * */\n\tstatic cartesian(cube) {\n\t\tif (!(cube instanceof Cube)){\n\t\t\tthrow TypeError('The argument must be instance of Cube')\n\t\t}\n\t\tconst f = (a, b) => [].concat(...a.map(d => {\n\t\t\treturn b.map(e => {\n\t\t\t\treturn [].concat(d, e)\n\t\t\t})\n\t\t}));\n\t\t\n\t\tconst cartesian = (a, b, ...c) => {\n\t\t\treturn b ? cartesian(f(a, b), ...c) : a\n\t\t};\n\t\t\n\t\tconst dimensionsOrder = [];\n\t\t\n\t\tconst set = cube.dimensionHierarchies.map(dimensionTree => dimensionTree.getTreeValue()).map(dimensionTable => {\n\t\t\tdimensionsOrder.push(dimensionTable.dimension);\n\t\t\treturn dimensionTable.members;\n\t\t});\n\t\t\n\t\tconst tupleList = [];\n\t\t\n\t\tlet res;\n\t\tif (set.length) {\n\t\t\tif (set.length > 1) {\n\t\t\t\tres = cartesian.apply(null, set);\n\t\t\t} else {\n\t\t\t\tres = set[0].map(i => [i])\n\t\t\t}\n\t\t\tres.forEach(arr => {\n\t\t\t\tconst item = {};\n\t\t\t\tdimensionsOrder.forEach((dimension, index) => {\n\t\t\t\t\titem[dimension] = arr[index]\n\t\t\t\t});\n\t\t\t\ttupleList.push(new Tuple(item));\n\t\t\t\treturn item;\n\t\t\t});\n\t\t}\n\t\t\n\t\treturn tupleList;\n\t}\n}\n\n/**\n * SubCube is the target cube whose members are members of the source cube.\n * */\nclass SubCube extends Cube {\n\tconstructor({originalCube, previousCube, ...rest}){\n\t\tsuper(rest);\n\t\t/** link for chaining between operations */\n\t\tthis.originalCube = originalCube;\n\t\t/** link for chaining between operations */\n\t\tthis.previousCube = previousCube;\n\t}\n}\n\n/**\n * @this {Cube}\n * @return {DimensionHierarchy}\n * */\nfunction getHierarchy(hierarchy) {\n\treturn this.dimensionHierarchies.find(dimensionHierarchy => {\n\t\treturn dimensionHierarchy.getHierarchy() === hierarchy\n\t});\n}\n/**\n * @this {Cube}\n * @return {DimensionTree}\n * */\nfunction getDimensionTreeByDimension(dimension) {\n\tlet findDimensionTree;\n\tthis.dimensionHierarchies.forEach(dimensionTree => {\n\t\tconst searchedDimensionTree = dimensionTree.getDimensionTreeByDimension(dimension);\n\t\tif (searchedDimensionTree) {\n\t\t\tfindDimensionTree = dimensionTree.getDimensionTreeByDimension(dimension);\n\t\t}\n\t});\n\tif (!findDimensionTree) {\n\t\tthrow RangeError(`Not existed dimension: ${dimension}`);\n\t}\n\treturn findDimensionTree;\n}\n/**\n * @this {Cube}\n * @return {DimensionTree[]}\n * */\nfunction getDimensionTrees() {\n\treturn this.dimensionHierarchies.map(dimensionHierarchy => {\n\t\treturn dimensionHierarchy.getDimensionTree\n\t\t\t? dimensionHierarchy.getDimensionTree()\n\t\t\t: dimensionHierarchy\n\t})\n}\n/**\n * @private\n * Get facts from cube\n * */\nfunction denormalize(cells = this.getCells(), forSave = true) {\n\tconst data = SnowflakeBuilder.denormalize(cells, getDimensionTrees.call(this));\n\tif (forSave) {\n\t\tdata.forEach((data, index) => {\n\t\t\tif (cells[index] instanceof EmptyCell) {\n\t\t\t\tdelete data[this.factPrimaryKey];\n\t\t\t}\n\t\t})\n\t}\n\treturn data;\n}\n/**\n * @public\n * Residuals - list of tuples, according to which there is more than one member\n * @return {Tuple[]}\n * */\nfunction residuals(cube) {\n\tconst tuples = Cube.cartesian(cube);\n\tconst totalTuples = [];\n\ttuples.forEach(tuple => {\n\t\tconst partFacts = cube.dice(tuple).getFacts();\n\t\tif (partFacts.length > 1) {\n\t\t\ttotalTuples.push(tuple)\n\t\t}\n\t});\n\treturn totalTuples;\n}\n/**\n * Unfilled - list of tuples, in accordance with which there is not a single member\n * @@param {Cube} cube\n * */\nfunction unfilled(cube) {\n\tconst tuples = Cube.cartesian(cube);\n\tconst unfilled = [];\n\ttuples.forEach(tuple => {\n\t\tconst members = this.dice(tuple).getFacts(tuple);\n\t\tif (members.length === 0) {\n\t\t\tunfilled.push(tuple)\n\t\t}\n\t});\n\treturn unfilled;\n}\n\nfunction validateFactData(factPrimaryKey, factData){\n\tif (!factData.hasOwnProperty(factPrimaryKey)) {\n\t\tthrow new NotFoundFactId(factPrimaryKey)\n\t}\n}\n\nexport default Cube"],"names":["InsufficientRollupData","[object Object]","dimension","id","this","message","NotFoundFactId","name","DimensionException","handleError","error","originalConsole","console","customConsole","log","string","warn","warnOnce","memory","isSimple","value","type","Fact","data","key","hasOwnProperty","Cell","uuidv4","replace","c","r","Math","random","toString","EmptyCell","options","generateId","super","cell","Member","Object","assign","props","primaryKey","isPrototypeOf","Error","memberData","forEach","prop","DEFAULT_TEMPLATE_FOREIGN_KEY","DEFAULT_FACT_ID_PROP","DEFAULT_MEMBER_ID_PROP","InputMember","defaultData","propName","create","DimensionTable","foreignKey","genericId","keyProps","otherProps","members","defaultMemberOptions","keys","indexOf","concat","map","splice","apply","length","member","push","memberOptions","linkProps","reduceId","addMember","reduce","acc","curValue","index","dimensionTable","Tree","getChildTrees","getParentTree","root","traceUpOrder","tracedTreeValue","tracedTree","isRoot","callback","parentTree","getTreeValue","childTrees","treeValue","childTree","tracePostOrder","tracePreOrder","DimensionTree","dimensionTree","level","parentNode","defineProperties","createDimensionTable","editable","enumerable","dimensionTreeData","validateDimensions","dimensions","tracedDimensionTreeValue","newDimensionTree","cloneDimensionTreeWithoutMembers","tracedDimension","getDimensionTreeByDimension","setMemberList","getRoot","search","dimensionTreeValue","newDimensionTreeByMember","projectDrillDown","projectDrillUp","projectDrill","traceMethodName","method","lastTracedMembers","lastTracedDimensionTree","tracedDimensionTree","drillMembers","clone","clearMemberList","projectionDimensionTree","subtractDimensionTree","endToBeRemovedMember","dimensionProjection","membersProjection","toBeRemovedSpace","tracedDimensionTable","childMembers","childDimension","removeMember","toBeAddedSpace","parentDimensionTable","parentMembers","parentMember","getMemberForeignKey","getMemberPrimaryKey","isExternal","childDimensionTable","childMember","childIdAttributes","createMember","DimensionHierarchy","activeDimension","hierarchy","createDimensionTree","dimensionHierarchy","SnowflakeBuilder","factTable","cells","dimensionsTrees","cellTable","factPrimaryKey","anotherBuildOne","processDimension","memberList","childDimensions","existMemberCount","args","entitiesParts","memberListForFilter","mapFilter","makeMemberListLevel","makeMemberList","deleteProps","fact","cellTables","cellTableFiltered","filter","whatIsIt","totalMemberList","countId","entitiesPart","etalon","childIdAttribute","entityPart","startFrom","cache","restoredCache","find","surrogateKey","createKeyFromProps","obj","join","removedCells","dimensionHierarchies","cube","removedCell","travers","removeMembers","bind","restoreCell","dimensionTrees","facts","memberCopy","deleteMemberId","dicedCube","dice","getCells","handlers","idValue","handler","handleDimensionTree","Tuple","Space","newSpace","arguments","space","add","targetSpace","otherSpace","Array","prototype","freeGlobal","global","freeSelf","self","Function","Symbol","objectProto","nativeObjectToString","symToStringTag","toStringTag","undefined","getRawTag","isOwn","call","tag","e","result","objectToString","nullTag","undefinedTag","baseGetTag","overArg","func","transform","arg","getPrototype","getPrototypeOf","isObjectLike","objectTag","funcProto","funcToString","objectCtorString","isPlainObject","proto","Ctor","constructor","Cube","TypeError","defaultFactOptions","createDimensionHierarchy","cellData","isEmptyCell","set","toOriginal","membersData","RangeError","originalMultiset","isArray","toMultiset","dimensionHierarchiesLength","projectionDimensionHierarchies","totalSpaces","dimensionTreeProjection","spacesForCells","searchedInTree","current","unionDimensionTree","union","filteredCellTable","cellBelongsToSpace","some","newDimensionHierarchies","originalDimensionHierarchy","finded","projectionDimensionHierarchy","createProxyDimensionTree","memberBelongToCells","filteredCell","removeProjectionOntoMember","SubCube","originalCube","previousCube","targetDimension","currentHierarchy","getHierarchy","hasDimension","setActiveDimension","denormalize","validateFactData","getFacts","anotherBuild","getDimensionTrees","removeCells","destroy","customMemberOptions","rollupCoordinatesData","drillDownCoordinatesOptions","getDimensionMembers","childDimensionTrees","foreignKeysMemberData","childDimensionTree","saveMember","saveIdAttribute","parentDimension","parentIdAttribute","drillDownCoordinatesData","fillEmptyCells","endToBeRemoved","getRemoveMeasures","destroyDimensionTree","cellOptions","emptyCells","cartesian","tuple","foreignKeysCellData","createEmptyCell","emptyCell","residuals","createEmptyCells","addEmptyCells","a","b","d","f","dimensionsOrder","tupleList","res","i","arr","item","rest","findDimensionTree","getDimensionTree","forSave","tuples","totalTuples","factData"],"mappings":"AAAO,MAAMA,uBACZC,YAAYC,EAAWC,GACtBC,KAAKC,0DAA4DH,cAAsBC,eAIzF,MAAaG,eACZL,YAAYM,GACXH,KAAKC,8DAAgEE,KAgBvE,MAAaC,mBACZP,YAAYC,GACXE,KAAKC,yBAA2BH,mCAI3B,MAAMO,YAAcC,IAE1B,MADAA,EAAML,kBAAoBK,EAAML,UAC1BK,GChCDC,gBAAkBC,QAClBC,cAAgB,CACrBC,IAAKC,IACJJ,gBAAgBG,cAAcC,MAE/BC,KAAMD,IACLJ,gBAAgBK,eAAeD,MAEhCE,SAAU,MACT,MAAMC,EAAS,GACf,OAAOH,IACDG,EAAOH,KACXG,EAAOH,IAAU,EACjBJ,gBAAgBK,eAAeD,QALxB,ICLLI,SAAYC,IACjB,IAAIC,SAAcD,EAClB,MAAgB,WAATC,GAA8B,aAATA,GAAgC,cAATA,GAAkC,OAAVD,GAG5E,MAAqBE,KAIpBrB,YAAYsB,GACX,IACC,IAAK,IAAIC,KAAOD,EAAM,CACrB,IAAKA,EAAKE,eAAeD,GACxB,OAGGL,SAASI,EAAKC,IACjBpB,KAAKoB,GAAOD,EAAKC,GAEjBZ,cAAQI,8BAA8BQ,gCAAkCD,EAAKC,OAG9E,MAAOd,GACRD,YAAYC,KCbA,MAAMgB,aAAaJ,MCXlC,SAASK,SACR,MAAO,uCAAuCC,QAAQ,QAAS,SAASC,GACvE,IAAIC,EAAoB,GAAhBC,KAAKC,SAAgB,EAE7B,OADa,KAALH,EAAWC,EAAS,EAAJA,EAAU,GACzBG,SAAS,MAQL,MAAMC,kBAAkBR,KACtCzB,YAAYsB,EAAMY,GACZZ,EAAKpB,KACToB,EAAKpB,GAAK+B,UAAUE,cAErBC,MAAMd,EAAMY,GAKblC,uBAAuBkC,GACtB,OAAO,IAAID,UAAUC,GAMtBlC,mBAAmBqC,GAClB,MAA0B,iBAAZA,EAAKnC,GAKpBF,oBACC,OAAO0B,UCnCT,MAAqBY,OACpBtC,YAAYsB,GACXiB,OAAOC,OAAOrC,KAAMmB,GAErBtB,cAAcE,EAAIuC,EAAOnB,EAAMoB,GAC9B,GAAMvC,OAASmC,SAAUA,OAAOK,cAAcxC,MAC7C,MAAMyC,MAAM,gDAEb,MAAMC,EAAa,GASnB,OARAA,EAAWH,GAAcxC,EAEzBuC,EAAMK,QAAQC,IAETA,IAASL,IACZG,EAAWE,GAAQzB,EAAKyB,MAGnB,IAAI5C,KAAK0C,ICpBX,MAAMG,6BAA+B,QAC/BC,qBAAuB,KACvBC,uBAAyB,KCIvB,MAAMC,oBAAoBb,OACxCtC,cAAcE,EAAI2C,EAAYvB,EAAMoB,GACnC,MACMU,EAAc,GAMpB,OAJAP,EAAWC,QAAQO,IAClBD,EAAYC,GAAY/B,EAAKE,eAAe6B,GAAY/B,EAAK+B,GAJzC,OAOdjB,MAAMkB,OAAOpD,EAAI2C,EAAYO,EAAaV,ICPnD,MAAqBa,eACpBvD,aAAYC,UAAEA,EAASuD,WAAEA,EAAaD,eAAeE,UAAUxD,GAAUyC,WAAEA,EAAaQ,uBAAsBQ,SAAEA,EAAQC,WAAEA,EAAa,GAAEC,QAAEA,EAAU,GAAEC,qBAAEA,EAAuB,KAC/K,IAAK5D,IAAcyD,EAClB,MAAMd,MAAM,gFAEb,IAA+D,IAA3DL,OAAOuB,KAAKD,GAAsBE,QAAQrB,GAC7C,MAAME,MAAM,kGAGbzC,KAAKF,UAAYA,EAEjBE,KAAKqD,WAAaA,EAElBrD,KAAKuC,WAAaA,EAElBvC,KAAKuD,SAAW,GAAGM,OAAON,GAE1BvD,KAAKwD,WAAa,GAAGK,OAAOL,GAE5BxD,KAAKyD,QAAUA,EAAQK,IAAIpB,GACnB,IAAIP,OAAOO,EAAY1C,KAAKuC,aAGpCvC,KAAK0D,qBAAuB,IAAIA,GAKjC7D,cAAc4D,GACb,GAAGM,OAAOC,MAAMhE,KAAKyD,QAAS,CAAC,EAAGzD,KAAKyD,QAAQQ,QAAQJ,OAAOJ,IAK/D5D,kBACCG,KAAKyD,QAAU,GAEhB5D,oBAAoBqE,GACnB,OAAOA,EAAOlE,KAAKuC,YAEpB1C,oBAAoBqE,GACnB,OAAOA,EAAOlE,KAAKqD,YAKpBxD,UAAUqE,IAC6B,IAAlClE,KAAKyD,QAAQG,QAAQM,GACxBlE,KAAKyD,QAAQU,KAAKD,GAElB1D,QAAQE,IAAI,OAQdb,aAAauE,EAAgB,GAAIC,GAEhC,MAAM3B,EAAa,IAAI1C,KAAK0D,wBAAyBU,IAC/Cb,SAAEA,EAAQC,WAAEA,EAAUC,QAAEA,EAAOlB,WAAEA,GAAevC,KAChD2D,EAAOJ,EAASM,OAAOQ,GAAWR,OAAOL,GACzCzD,EAAKqD,eAAekB,SAASb,EAASlB,GACtC2B,EAASlB,YAAYG,OAAOpD,EAAI4D,EAAMjB,EAAYH,GAExD,OADAvC,KAAKuE,UAAUL,GACRA,EAMRrE,gBAAgB4D,EAASlB,GACxB,OAAIkB,EAAQQ,OACJR,EAAQe,OAAO,CAACC,EAAKC,IACpBD,EAAIlC,GAAcmC,EAASnC,GAAckC,EAAMC,EACpD,GAAGnC,GAAc,EAEb,EAOT1C,iBAAiBC,GAChB,OAAO+C,6BAA6BrB,QAAQ,KAAM1B,GAEnDD,YAAYqE,EAAQnE,GACnBmE,EAAOlE,KAAKuC,YAAcxC,EAE3BF,eAAeqE,UACPA,EAAOlE,KAAKuC,YAKpB1C,aAAaqE,GACZ,MAAMS,EAAQ3E,KAAKyD,QAAQG,QAAQM,GACnC,IAAe,IAAXS,EACH,MAAM,IAAIlC,MAAM,mCAAoCyB,GAErDlE,KAAKyD,QAAQM,OAAOY,EAAO,GAE5B9E,4BAA4B+E,GAC3B,OAAO,IAAIxB,eAAewB,IC5G5B,MAAqBC,KAMpBhF,eACC,KAAM,kBAOPA,gBACC,KAAM,kBAOPA,gBACC,KAAM,kBAMPA,aACC,OAAQG,KAAK8E,gBAAgBb,OAM9BpE,SACC,OAAgC,OAAzBG,KAAK+E,gBAOblF,UACC,IAAImF,EAAOhF,KAMX,OALAA,KAAKiF,aAAa,CAACC,EAAiBC,KAC/BA,EAAWC,WACdJ,EAAOG,KAGFH,EAORnF,aAAawF,GACZ,MACMC,EADOtF,KACW+E,gBAExBM,EAHarF,KAEUuF,eAFVvF,MAIM,OAAfsF,GACHA,EAAWL,aAAaI,GAQ1BxF,eAAewF,GACd,MACMG,EADOxF,KACW8E,gBAClBW,EAFOzF,KAEUuF,eACnBC,EAAWvB,QACduB,EAAW7C,QAAQ+C,IAClBA,EAAUC,eAAeN,KAG3BA,EAASI,EARIzF,MAcdH,cAAcwF,GACb,MACMG,EADOxF,KACW8E,gBAClBW,EAFOzF,KAEUuF,eACvBF,EAASI,EAHIzF,MAITwF,EAAWvB,QACduB,EAAW7C,QAAQ+C,IAClBA,EAAUE,cAAcP,MC5Fb,MAAMQ,sBAAsBhB,KAC1ChF,YAAYiG,GACX7D,QAEA,MAAM2C,eAACA,EAAcmB,MAAEA,EAAQ,GAAEC,WAAEA,EAAa,MAAQF,EAExD1D,OAAO6D,iBAAiBjG,KAAM,CAC7B4E,eAAgB,CAKf5D,MAAOoC,eAAe8C,qBAAqBtB,GAC3CuB,UAAU,EACVC,YAAY,GAEbJ,WAAY,CAKXhF,MAAOgF,EACPI,YAAY,EACZD,UAAU,GAEXJ,MAAO,CAKN/E,MAAO+E,EAAMjC,IAAIuC,GACT,IAAIR,cAAc,IAAKQ,EAAmBL,WAAYhG,QAE9DoG,YAAY,EACZD,UAAU,KAGZnG,KAAKsG,qBAENzG,qBACC,MAAM0G,EAAa,GACnBvG,KAAK2F,eAAea,IACnB,MAAM1G,UAACA,GAAa0G,EACpB,IAAuC,IAAnCD,EAAW3C,QAAQ9D,GAGtB,MAAM,IAAIM,mBAFVmG,EAAWpC,KAAKrE,KAMnBD,2BAA2BwG,GAE1B,OAAO,IAAIR,cAAcQ,GAE1BxG,gCAAgCiG,GAC/B,MAAMW,EAAmBX,EAAcY,mCASvC,OARAZ,EAAcH,eAAeT,IAC5B,MAAQpF,UAAW6G,EAAelD,QAAEA,GAAYyB,EAEhDuB,EACEG,4BAA4BD,GAC5BpB,eACAsB,cAAcpD,KAEVgD,EAMR5G,eACC,OAAOG,KAAK4E,eAMb/E,gBACC,OAAOG,KAAKgG,WAMbnG,gBACC,OAAOG,KAAK+F,MAOblG,4BAA4BC,GAC3B,MAAMkF,EAAOhF,KAAK8G,UAClB,IAAIC,OAAS,EAMb,OALA/B,EAAKW,eAAe,CAACqB,EAAoBlB,KACpCkB,EAAmBlH,YAAcA,IACpCiH,EAASjB,KAGJiB,EAORlH,2BAA2BqE,GAE1B,MAAM+C,EAA2BjH,KAAK0G,mCAKtC,OAHA1G,KAAKkH,iBAAiBD,EAA0B/C,GAChDlE,KAAKmH,eAAeF,EAA0B/C,GAEvC+C,EAERpH,iBAAiBiG,EAAe5B,GAC/BlE,KAAKoH,aAAatB,EAAe5B,EAAQ,eAAgB,6BAE1DrE,eAAeiG,EAAe5B,GAC7BlE,KAAKoH,aAAatB,EAAe5B,EAAQ,gBAAiB,2BAE3DrE,aAAaiG,EAAe5B,EAAQmD,EAAiBC,GACpD,IAAIC,EACAC,EACJxH,KAAKqH,GAAiB,CAACb,EAA0BiB,KAChD,MAAQ3H,UAAW6G,GAAoBH,EAEjCkB,EAAeD,GAAuBzH,KACzC,CAACkE,GACDsD,EAAwBF,GAAQC,GAEnCzB,EACEc,4BAA4BD,GAC5BpB,eACAsB,cAAca,GAEhBH,EAAoBG,EACpBF,EAA0BC,IAG5B5H,mCAEC,MAAM8H,EAAQ,IAAI9B,cAAc7F,KAAK8G,WAIrC,OAHAa,EAAMhC,eAAeqB,IACpBA,EAAmBY,oBAEbD,EAMR9H,2BAA2BqE,GAE1B,MAAM2D,EAA0B7H,KAAK0G,mCACrC1G,KAAKkH,iBAAiBW,EAAyB3D,GAG/ClE,KAAK8H,sBAAsBD,GAE3B,MAAME,EAAuB,IAG5BjI,UAAWkI,EACXvE,QAASwE,GACNJ,EAAwBf,UAAUvB,eAItC,OAFAwC,EAAqBC,GAAuBC,EAErCF,EAMRlI,sBAAsBiG,GAErB,MAAMoC,EAAmB,GAEzBpC,EAAcH,eAAeqB,IAC5B,MAAMlH,UAACA,EAAS2D,QAAEA,GAAWuD,EAC7BkB,EAAiBpI,GAAa2D,IAML,IAHPzD,KAAKuF,eAAe9B,QAGxBQ,QACdjE,KAAK4F,cAAc,CAACuC,EAAsBV,KACzC,MAAOhE,QAAS2E,EAActI,UAAWuI,GAAkBF,EAC3DD,EAAiBG,GAAkBD,IAKrChG,OAAOuB,KAAKuE,GAAkBvF,QAAQ7C,IACrC,MACM8E,EADuB5E,KAAK4G,4BAA4B9G,GAClByF,eAC5C2C,EAAiBpI,GAAW6C,QAAQuB,IACnCU,EAAe0D,aAAapE,OAI/BrE,mBAAmBiG,GAClB,MAAMyC,EAAiB,GACvBzC,EAAcH,eAAeqB,IAC5B,MAAMlH,UAACA,EAAS2D,QAAEA,GAAWuD,EAC7BuB,EAAezI,GAAa2D,IAG7BrB,OAAOuB,KAAK4E,GAAgB5F,QAAQ7C,IACnC,MACM8E,EADuB5E,KAAK4G,4BAA4B9G,GAClByF,eAC5CgD,EAAezI,GAAW6C,QAAQuB,IACjCU,EAAeL,UAAUL,OAS5BrE,0BAA0B4D,EAAUzD,KAAKuF,eAAe9B,SACvD,GAAIzD,KAAKoF,SACR,OAAO3B,EAER,MACM+E,EADaxI,KAAK+E,gBACgBQ,eAClCX,EAAiB5E,KAAKuF,gBACpB9B,QAASgF,GAAkBD,EAC7Bd,EAAe,GAUrB,OATAjE,EAAQd,QAAQuB,IACfuE,EAAc9F,QAAQ+F,IACjB9D,EAAe+D,oBAAoBD,KAAkBF,EAAqBI,oBAAoB1E,KACrD,IAAxCwD,EAAa9D,QAAQ8E,IACxBhB,EAAavD,KAAKuE,OAKfhB,EAQR7H,wBAAwB4D,EAAUzD,KAAKuF,eAAe9B,SACrD,GAAIzD,KAAK6I,aACR,OAAOpF,EAER,MACMqF,EADY9I,KAAK8E,gBAAgB,GACDS,gBAC9B9B,QAAS2E,GAAiBU,EAC5BpB,EAAe,GAUrB,OATAjE,EAAQd,QAAQuB,IACfkE,EAAazF,QAAQoG,IAChBD,EAAoBH,oBAAoBzE,KAAY4E,EAAoBF,oBAAoBG,KACpD,IAAvCrB,EAAa9D,QAAQmF,IACxBrB,EAAavD,KAAK4E,OAKfrB,EAMR7H,aAAauE,EAAgB,IAC5B,MAAMQ,EAAiB5E,KAAKuF,eACtByD,EAAoBhJ,KAAK8E,gBAAgBhB,IAAIgC,GAClDA,EAAcP,eAAelC,YAExBgB,EAAY,GAIlB,OAHA2E,EAAkBrG,QAAQU,IACzBgB,EAAUF,KAAKd,KAETuB,EAAeqE,aAAa7E,EAAeC,IC3RpD,MAAqB6E,mBACpBrJ,aAAYiG,cAAEA,EAAaqD,gBAAEA,EAAeC,UAAEA,IAC7C,IAAKA,EACJ,MAAM3G,MAAM,yCAEbzC,KAAK8F,cAAgBA,aAAyBD,cAC3CC,EACAD,cAAcwD,oBAAoBvD,GACrC9F,KAAKmJ,gBAAkBA,GAAmBnJ,KAAK8F,cAAcP,eAAezF,UAC5EE,KAAKoJ,UAAYA,EAElBvJ,mBACC,OAAOG,KAAK8F,cAEbjG,aAAaC,GACZ,QAASE,KAAK8F,cAAcc,4BAA4B9G,GAEzDD,qBACC,OAAOG,KAAKmJ,gBAEbtJ,mBAAmBsJ,GAClBnJ,KAAKmJ,gBAAkBA,EAExBtJ,eACC,OAAOG,KAAKoJ,UAEbvJ,gCAAgCyJ,GAC/B,OAAO,IAAIJ,mBAAmBI,ICvBhC,MAAqBC,iBACpB1J,oBAAoB2J,EAAWC,EAAOC,EAAiBC,EAAWC,GAGjEF,EAAgB/G,QAAQmD,IACvByD,iBAAiBM,gBAAgB/D,EAAe2D,EAAOE,EAAWH,EAAWI,KAI/E/J,uBAAuBiG,EAAe2D,EAAOE,EAAWH,EAAWI,GAElE9D,EAAcH,eAAe,CAACf,EAAgBkB,KAC7CyD,iBAAiBO,iBAAiBhE,EAAe2D,EAAOE,EAAWH,EAAWI,KAIhF/J,wBAAwBiG,EAAe2D,EAAOE,EAAWH,EAAWI,GACnE,MAAMhF,EAAiBkB,EAAcP,gBAC/BzF,UAAEA,EAASyD,SAAEA,EAAW,GAAEC,WAAEA,EAAa,GAAIC,QAASsG,EAAU1G,WAAEA,EAAUd,WAAEA,GAAeqC,EAC7FoE,EAAoBlD,EAAchB,gBAAgBhB,IAAIgC,GAAiBA,EAAcP,eAAelC,YACpG2G,EAAkBlE,EAAchB,gBAAgBhB,IAAIgC,GAAiBA,EAAcP,eAAezF,WAExG,IAAI2D,EAEJ,MAAMwG,EAAmBF,EAAW9F,OAC9BiG,EAAO,CAACN,EAAgBrH,EAAYc,EAAY4G,EAAkBT,EAAWC,EAAO3J,EAAWyD,EAAUC,EAAYiG,EAAOE,GAElI,GAAKX,EAAkB/E,OAEhB,CACN,IAAIkG,EAAgB,GACpB,MAAMvF,EAAiBkB,EAAcc,4BAA4BoD,EAAgB,IAAIzE,eAC/E6E,EAAsBxF,EAAenB,QAC3C0G,EAAgBZ,iBAAiBc,UAAUrB,EAAkB,GAAIS,EAAOW,EAAqBxF,GAC7FnB,EAAU8F,iBAAiBe,oBAAoBtG,MAAM,KAAMkG,EAAKrG,OAAO,CAACmF,EAAmBmB,UAN3F1G,EAAU8F,iBAAiBgB,eAAevG,MAAM,KAAMkG,GASvD,SAASM,EAAYC,EAAMnI,EAAOsH,GACjCtH,EAAMK,QAAQC,IACTA,IAASgH,UACLa,EAAK7H,KAMf6G,EAAM9G,QAAQT,IACbsI,EAAYtI,EAAMqB,EAAUqG,GAC5BY,EAAYtI,EAAMsB,EAAYoG,KAG/BnG,EAAQd,QAAQuB,IACfU,EAAeL,UAAUL,KAY3BrE,iBAAiBwD,EAAYoG,EAAOM,EAAYnF,GAC/C,MAAM8F,EAAa,GAQnB,OANAX,EAAWpH,QAAQuB,IAClB,MAAMyG,EAAoBlB,EAAMmB,OAAO1I,GAC/BA,EAAKmB,IAAeuB,EAAegE,oBAAoB1E,IAE/DwG,EAAWvG,KAAKwG,KAEVD,EAKR7K,2BAA2B+J,EAAgBrH,EAAYc,EAAY4G,EAAkBT,EAAWqB,EAAU/K,EAAWyD,EAAUC,EAAYiG,EAAOE,EAAWX,EAAmBmB,GAC/K,IAAIW,EAAkB,GAElBC,EAAU,EAwBd,OAvBAZ,EAAcxH,QAAQqI,IACrB,GAAIA,EAAa/G,OAAQ,CACxB,MAAMR,EAAU8F,iBAAiBgB,eAAeX,EAAgBrH,EAAYc,EAAY4G,EAAkBT,EAAWwB,EAAclL,EAAWyD,EAAUC,EAAYiG,EAAOE,EAAWoB,GACtLA,GAAoBtH,EAAQQ,OAE5B,MAAMgH,EAASD,EAAa,GAE5BhC,EAAkBrG,QAAQuI,IAEzBzH,EAAQd,QAAQuB,IACfA,EAAOgH,GAAoBD,EAAOC,GAClChH,EAAO3B,GAAe0H,EAAmBa,EAAgB7G,OAAS,EAClE6G,EAAgB3G,KAAKD,KAGtB8G,EAAarI,QAAQwI,WACbA,EAAWD,UAOfJ,EAgBRjL,sBACC+J,EACArH,EACAc,EACA4G,EACAT,EACAwB,EACAlL,EACAyD,EAAW,GACXC,EAAa,GACbiG,EACAE,EAEAyB,EAAY,GAGZ,MAAMC,EAAQ,GACRC,EAAgB,GAChB7H,EAAU,GAuChB,OApCqBkG,EAAUiB,OAAO1I,IACL,IAAzBuH,EAAM7F,QAAQ1B,IAETS,QAAQT,IAEpB,MAAMuI,EAAOjB,EAAU+B,KAAKd,GAAQA,EAAKb,KAAoB1H,EAAK0H,IAC5D4B,EAAejC,iBAAiBkC,mBAAmBlI,EAAUkH,GAE7De,KAAgBF,IACrBA,EAAcE,KAAkBJ,KAKlCJ,EAAarI,QAAQwI,IAGpB,MAAMK,EAAejC,iBAAiBkC,mBAAmBlI,EAAU4H,GAG7DK,KAAgBH,GAAYG,KAAgBF,IACjDD,EAAMG,KAAkBJ,GAIzB,MAAMrL,EAAKsL,EAAMG,GACjBL,EAAW9H,GAActD,IAG1BqC,OAAOuB,KAAK0H,GAAO1I,QAAQvB,IAC1B,MAAMrB,EAAKsL,EAAMjK,GACX+J,EAAaH,EAAaO,KAAKJ,GAAcA,EAAW9H,KAAgBtD,GACxEmE,EAAS/B,OAAOgB,OAAOpD,EAAI,GAAG8D,OAAON,GAAUM,OAAOL,GAAa2H,EAAY5I,GACrFkB,EAAQU,KAAKD,KAGPT,EAGR5D,0BAA0ByC,EAAOoJ,GAGhC,OAAOpJ,EAAMwB,IAAIlB,GACT8I,EAAI9I,IACT+I,KAJa,KAOjB9L,eAAe8J,EAAWiC,EAAcC,EAAsBC,GAE7DF,EAAajJ,QAAQoJ,IACpB,MAAMpH,EAAQgF,EAAU/F,QAAQmI,IACjB,IAAXpH,GACHgF,EAAU5F,OAAOY,EAAO,KAI1BiH,EAAajJ,QAAQ8H,IACpBoB,EAAqBlJ,QAAQmD,IAC5ByD,iBAAiByC,QAAQ,CAACvB,GAAO3E,EAAe,CAACyD,iBAAiB0C,cAAcC,KAAKlM,KAAM8L,EAAMhG,GAAgByD,iBAAiB4C,kBAQrItM,mBAAmB8J,EAAWyC,GAC7B,MAAMC,EAAQ,GAUd,OATA1C,EAAUhH,QAAQT,IACjBmK,EAAMlI,KAAK,IAAIjC,MAEhBmK,EAAM1J,QAAQ8H,IACb2B,EAAezJ,QAAQmD,IACtByD,iBAAiByC,QAAQ,CAACvB,GAAO3E,EAAe,CAACyD,iBAAiB4C,kBAI7DE,EAERxM,mBAAmBqE,EAAQ6F,EAAYjK,EAAWoC,EAAMmB,EAAYuB,GACnE,MAAM0H,EAAa,IAAInK,OAAO+B,GAC9BU,EAAe2H,eAAeD,UACvBpK,EAAKmB,GACZjB,OAAOC,OAAOH,EAAMoK,GAErBzM,qBAAqBiM,EAAMhG,EAAe5B,EAAQ6F,EAAYjK,EAAWoC,EAAMmB,GAC9E,MAAMmJ,EAAYV,EAAKW,KAAK,CAAE5M,CAACC,GAAYoE,IACrCU,EAAiBkB,EAAcc,4BAA4B9G,GAAWyF,eAGvEiH,EAAUE,WAAWzI,QACzBW,EAAe0D,aAAapE,GAI9BrE,eAAe8J,EAAW7D,EAAe6G,EAAW,UAWnDhD,EAAUhH,QAAQT,IACjB4D,EAAcF,cAAc,CAACuC,EAAsBV,KAXxB,EAAC7C,EAAgB1C,KAC5C,MAAMpC,UAAEA,EAAW2D,QAASsG,EAAU1G,WAAEA,GAAeuB,EACjDgI,EAAU1K,EAAKmB,GACfa,EAAS6F,EAAWwB,KAAKrH,GACvBU,EAAegE,oBAAoB1E,KAAY0I,GAEvDD,EAAShK,QAAQkK,IAChBA,EAAQ3I,EAAQ6F,EAAYjK,EAAWoC,EAAMmB,EAAYuB,MAKzDkI,CAAoB3E,EAAsBjG,OAS7CrC,4BAA4B8J,EAAWiC,EAAc9F,EAAegG,GACnEvC,iBAAiByC,QAAQrC,EAAW7D,EAAe,CAACyD,iBAAiB0C,cAAcC,KAAKlM,KAAM8L,EAAMhG,GAAgByD,iBAAiB4C,eCzQvI,MAAqBY,MACpBlN,YAAYkC,GACXK,OAAOC,OAAOrC,KAAM+B,ICPP,MAAMiL,MAIpBnN,eACC,MAAMoN,EAAW,GAKjB,MAJY,IAAIC,WACZvK,QAAQwK,IACXH,MAAMI,IAAIH,EAAUE,KAEdF,EAKRpN,WAAWwN,EAAaC,GACvBlL,OAAOuB,KAAK2J,GAAY3K,QAAQvB,IAC1BiM,EAAYjM,KAChBiM,EAAYjM,GAAO,IAEpBmM,MAAMC,UAAUrJ,KAAKH,MAAMqJ,EAAYjM,GAAMkM,EAAWlM,OCnB3D,IAAIqM,WAA8B,iBAAVC,QAAsBA,QAAUA,OAAOtL,SAAWA,QAAUsL,OCEhFC,SAA0B,iBAARC,MAAoBA,MAAQA,KAAKxL,SAAWA,QAAUwL,KAGxE5I,KAAOyI,YAAcE,UAAYE,SAAS,cAATA,GCHjCC,OAAS9I,KAAK8I,OCAdC,YAAc3L,OAAOoL,UAGrBnM,eAAiB0M,YAAY1M,eAO7B2M,qBAAuBD,YAAYlM,SAGnCoM,eAAiBH,OAASA,OAAOI,iBAAcC,EASnD,SAASC,UAAUpN,GACjB,IAAIqN,EAAQhN,eAAeiN,KAAKtN,EAAOiN,gBACnCM,EAAMvN,EAAMiN,gBAEhB,IACEjN,EAAMiN,qBAAkBE,EAExB,MAAOK,IAET,IAAIC,EAAST,qBAAqBM,KAAKtN,GAQvC,OANMqN,EACFrN,EAAMiN,gBAAkBM,SAEjBvN,EAAMiN,gBAGVQ,ECzCT,IAAIV,cAAc3L,OAAOoL,UAOrBQ,uBAAuBD,cAAYlM,SASvC,SAAS6M,eAAe1N,GACtB,OAAOgN,uBAAqBM,KAAKtN,GCbnC,IAAI2N,QAAU,gBACVC,aAAe,qBAGfX,iBAAiBH,OAASA,OAAOI,iBAAcC,EASnD,SAASU,WAAW7N,GAClB,OAAa,MAATA,OACemN,IAAVnN,EAAsB4N,aAAeD,QAEtCV,kBAAkBA,oBAAkB7L,OAAOpB,GAC/CoN,UAAUpN,GACV0N,eAAe1N,GChBrB,SAAS8N,QAAQC,EAAMC,GACrB,OAAO,SAASC,GACd,OAAOF,EAAKC,EAAUC,KCP1B,IAAIC,aAAeJ,QAAQ1M,OAAO+M,eAAgB/M,QCqBlD,SAASgN,aAAapO,GACpB,OAAgB,MAATA,GAAiC,iBAATA,ECpBjC,IAAIqO,UAAY,kBAGZC,UAAYzB,SAASL,UACrBO,cAAc3L,OAAOoL,UAGrB+B,aAAeD,UAAUzN,SAGzBR,iBAAiB0M,cAAY1M,eAG7BmO,iBAAmBD,aAAajB,KAAKlM,QA8BzC,SAASqN,cAAczO,GACrB,IAAKoO,aAAapO,IAAU6N,WAAW7N,IAAUqO,UAC/C,OAAO,EAET,IAAIK,EAAQR,aAAalO,GACzB,GAAc,OAAV0O,EACF,OAAO,EAET,IAAIC,EAAOtO,iBAAeiN,KAAKoB,EAAO,gBAAkBA,EAAME,YAC9D,MAAsB,mBAARD,GAAsBA,aAAgBA,GAClDJ,aAAajB,KAAKqB,IAASH,iBClC/B,MAAMK,KAKLhQ,YAAYiM,EAAO,IAClB,KAAM2D,cAAc3D,IAASA,aAAgB+D,MAC5C,MAAMC,UAAU,yDAEjB,IAAIjE,qBACHA,EAAuB,GAAElC,UACzBA,EAAY,GAAEoG,mBACdA,EAAqB,GAAEnG,eACvBA,EAAiB9G,sBACdgJ,EAEJ9L,KAAK+P,mBAAqBA,EAC1B/P,KAAK4J,eAAiBA,EAEtB5J,KAAK6L,qBAAuBA,EAAqB/H,IAAIwF,GAEhDA,EAAmBF,UAClBE,aAA8BJ,mBAC1BI,EAEAJ,mBAAmB8G,yBAAyB1G,GAE1CA,EAAmB1E,eACxB0E,aAA8BzD,cAC3ByD,EAEAzD,cAAcwD,oBAAoBC,GAGtCA,aAA8BlG,eAC1BkG,EAEAlG,eAAe8C,qBAAqBoD,IAK9CtJ,KAAK2J,UAAYA,EAAU7F,IAAImM,GAC1BA,aAAoB3O,KAChB2O,EAEAnO,UAAUoO,YAAYD,GAAY,IAAInO,UAAUmO,GAAY,IAAI3O,KAAK2O,IAkB/EpQ,MAAMC,EAAWoE,GAChB,OAAOlE,KAAKyM,KAAK,CAAE5M,CAACC,GAAYoE,IASjCrE,KAAKsQ,GACJ,KAAMV,cAAcU,IAAQA,aAAepD,OAC1C,MAAM+C,UAAU,uCAIjB,MAKMM,EAAa,CAACC,EAAavQ,KAChC,MACM8E,EADgBgC,4BAA4B0H,KAAKtO,KAAMF,GACxByF,eAC/B9B,EAAUmB,EAAenB,QAY/B,OAVA4M,EAAY1N,QAAQ,CAACD,EAAYiC,KAChC,IAAIT,EAAST,EAAQ8H,KAAKrH,GAAUU,EAAegE,oBAAoB1E,KAAYU,EAAegE,oBAAoBlG,IACtH,IAAKwB,EACJ,MAAMoM,qCAAqC1L,EAAegE,oBAAoB1E,MAE3EmM,aAAuBlO,SAG3BkO,EAAY1L,GAAST,KAEfmM,GAGFE,EAAmB,GACzBnO,OAAOuB,KAAKwM,GAAKxN,QAAS7C,IACzB,IAAIkB,EAAQmP,EAAIrQ,GAChBkB,EA1BkB,CAACA,GACZuM,MAAMiD,QAAQxP,GAASA,EAAQ,CAACA,GAyB/ByP,CAAWzP,GACnBA,EAAQoP,EAAWpP,EAAOlB,GAC1ByQ,EAAiBzQ,GAAakB,IAG/B,MAAMuF,EAAanE,OAAOuB,KAAK4M,GAGzBG,EAA6B1Q,KAAK6L,qBAAqB5H,OAC7D,GAAIsC,EAAWtC,OAASyM,EACvB,MAAMjO,4CAA4CiO,gBAGnD,MAAMC,EAAiC,GAGjCC,EAAcrK,EAAWzC,IAAIhE,IAElC,IAAI+Q,EACJ,MAEMC,EAFUP,EAAiBzQ,GAEFgE,IAAII,IAElC,IAAI6M,EAAiBnK,4BAA4B0H,KAAKtO,KAAMF,GAE5D,MAAMkR,EAAUD,EAAerK,mCAE/BqK,EAAe7J,iBAAiB8J,EAAS9M,GACzC6M,EAAe5J,eAAe6J,EAAS9M,GAEnC2M,EACHA,EAAwBI,mBAAmBD,GAE3CH,EAA0BG,EAE3B,MACClR,UAAWkI,EACXvE,QAASwE,GACN4I,EAAwB/J,UAAUvB,eAEtC,MAAO,CAAE1F,CAACmI,GAAsBC,KAUjC,OAPI4I,GACHF,EAA+BxM,KAAK0M,GAIlB7D,MAAMkE,SAASJ,KAMnC,IAAIK,EAAoBnR,KAAK0M,WAE7B,MAAM0E,EAAqB,CAAClP,EAAMiL,KASjC,OARuC/K,OAAOuB,KAAKwJ,GAAOkE,KAAKvR,IAC9D,MAAM2D,EAAU0J,EAAMrN,IAChBuD,WAAEA,EAAUd,WAAEA,GAAeqE,4BAA4B0H,KAAKtO,KAAMF,GAAWyF,eAIrF,OAHe9B,EAAQ8H,KAAKrH,GACpBA,EAAO3B,KAAgBL,EAAKmB,OAOtCuN,EAAYjO,QAAQwK,IAEnBgE,EAAoBA,EAAkBvG,OAAO1I,GACrCkP,EAAmBlP,EAAMiL,MAKlC,MAAMmE,EAA0B,GA+BhC,OA9BAtR,KAAK6L,qBAAqBlJ,QAAQ4O,IACjC,IAAIC,GAAS,EAOb,GANAb,EAA+BhO,QAAQ8O,IAClCF,EAA2BhM,eAAezF,YAAc2R,EAA6BlM,eAAezF,YACvGwR,EAAwBnN,KAAKsN,GAC7BD,GAAS,MAGNA,EAAQ,CACZ,MAAM/N,QAAEA,EAAO3D,UAAEA,GAAcyR,EAA2BhM,eACpDkM,EAA+B5L,cAAc6L,yBAAyBH,GAC5E9N,EAAQd,QAAQuB,IACf,IAAIyN,GAAsB,EAM1B,GALAR,EAAkBxO,QAAQiP,IACrBR,EAAmBQ,EAAc,CAAE/R,CAACC,GAAY,CAACoE,OACpDyN,GAAsB,MAGnBA,EAAqB,EAC0D,IAAzEF,EAA6BlM,eAAe9B,QAAQG,QAAQM,IAErEuN,EAA6BI,2BAA2B3N,MAK3DoN,EAAwBnN,KAAKsN,MAIxB,IAAIK,QAAQ,CAClBnI,UAAWwH,EACXtF,qBAAsByF,EACtBS,aAAc/R,KAAK+R,cAAgB/R,KACnCgS,aAAchS,OAWhBH,QAAQuJ,EAAW6I,GAClB,MAAMC,EAAmBC,aAAa7D,KAAKtO,KAAMoJ,GAIjD,OAHI8I,GAAoBA,EAAiBE,aAAaH,IACrDC,EAAiBG,mBAAmBJ,GAE9BjS,KAURH,UAAUuJ,EAAW6I,GACpB,MAAMC,EAAmBC,aAAa7D,KAAKtO,KAAMoJ,GAIjD,OAHI8I,GAAoBA,EAAiBE,aAAaH,IACrDC,EAAiBG,mBAAmBJ,GAE9BjS,KAMRH,WACC,OAAOyS,YAAYhE,KAAKtO,KAAMA,KAAK0M,YAQpC7M,SAASwM,GACR,IAAKkB,MAAMiD,QAAQnE,GAClB,MAAMyD,UAAU,0CAEjBzD,EAAM1J,QAAQ4P,iBAAiBrG,KAAK,KAAMlM,KAAK4J,iBAC/C,MAAMH,EAAQ4C,EAAMvI,IAAI2G,GAAQ,IAAInJ,KAAKmJ,IACzC,GAAGtG,KAAKH,MAAMhE,KAAK0M,WAAYjD,GAC/B,MAAMD,EAAYxJ,KAAKwS,WAEvB,OADAjJ,iBAAiBkJ,aAAajJ,EAAWC,EAAOiJ,kBAAkBpE,KAAKtO,MAAOA,KAAK0M,WAAY1M,KAAK4J,gBAC7F5J,KAORH,YAAYwM,GACX,IAAKkB,MAAMiD,QAAQnE,GAClB,MAAMyD,UAAU,0CAEjB,MAAMnG,EAAY3J,KAAK0M,WACjB9C,EAAiB5J,KAAK4J,eACtBgC,EAAeS,EAAMvI,IAAI2G,GACvBd,EAAU4B,KAAKrJ,GAAQA,EAAK0H,KAAoBa,EAAKb,KAE7D5J,KAAK2S,YAAY/G,GAMlB/L,WACC,OAAOG,KAAK2J,UAOb9J,YAAY4J,GACX,IAAK8D,MAAMiD,QAAQ/G,GAClB,MAAMqG,UAAU,0CAEjBrG,EAAM9G,QAAST,IACd,KAAMA,aAAgBZ,MACrB,MAAMwO,UAAU,yEAGlBvG,iBAAiBqJ,QAAQ5S,KAAK0M,WAAYjD,EAAOzJ,KAAK6L,qBAAsB7L,MAQ7EH,oBAAoBC,GACnB,GAA2B,iBAAdA,EACZ,MAAMgQ,UAAU,qCAGjB,OADsBlJ,4BAA4B0H,KAAKtO,KAAMF,GACxCyF,eAAe9B,QAWrC5D,mBAAmBC,EAAW+S,EAAsB,GAAIC,EAAwB,GAAIC,EAA8B,GAAI9C,EAAW,IAChI,GAA2B,iBAAdnQ,EACZ,MAAMgQ,UAAU,iDAEjB,KACCL,cAAcoD,IACXpD,cAAcqD,IACdrD,cAAcsD,IACdtD,cAAcQ,IAEjB,MAAMH,UAAU,uDAKjB1N,OAAOuB,KAAKmP,GAAuBnQ,QAAQ7C,IAC1C,MAAM4C,EAAaoQ,EAAsBhT,GACnCiK,EAAa/J,KAAKgT,oBAAoBlT,GACtC8E,EAAiBgC,4BAA4B0H,KAAKtO,KAAMF,GAAWyF,gBACnEhD,WAAEA,GAAeqC,EACjB7E,EAAK2C,EAAWH,GAItB,IAHawH,EAAWwB,KAAKrH,GACrBnE,IAAO6E,EAAegE,oBAAoB1E,IAGjD,MAAM,IAAItE,uBAAuBE,EAAWC,KAK9C,MAAM+F,EAAgBc,4BAA4B0H,KAAKtO,KAAMF,GACvDmT,EAAsBnN,EAAchB,gBACpCF,EAAiBkB,EAAcP,gBAC/BlC,WAAEA,GAAeuB,EACjBsO,EAAwB,GAC9BD,EAAoBtQ,QAAQwQ,IAC3B,MAAMvO,EAAiBuO,EAAmB5N,gBACpCzF,UAAEA,EAASuD,WAAEA,EAAUd,WAAEA,GAAeqC,EACxCV,EAAS4O,EAAsBhT,GACrC,IAAKoE,EACJ,MAAM,IAAItE,uBAAuBE,GAEjCoT,EAAsB7P,GAAca,EAAO3B,KAI7C,MAAM6B,EAAgBhC,OAAOC,OAAO,GAAIwQ,EAAqBK,GAE7D,IAAIE,EAAatN,EAAcmD,aAAa7E,GACxCiP,EAAkBhQ,EACtByC,EAAcb,aAAa,CAACkD,EAAsBV,KACjD,GAAI3B,IAAkB2B,EAAqB,CAC1C,MAAQ3H,UAAWwT,EAAiBjQ,WAAYkQ,GAAsBpL,EAChEqL,EAA2B,CAAE3T,CAAEwT,GAAkBzO,EAAegE,oBAAoBwK,IAC1FhR,OAAOC,OAAOmR,EAA0BT,EAA4BO,IACpEF,EAAa3L,EAAoBwB,aAAauK,GAC9CH,EAAkBE,KAGpBvT,KAAKyT,eAAexD,GAQrBpQ,sBAAsBC,EAAWoE,GAChC,GAA2B,iBAAdpE,EACZ,MAAMgQ,UAAU,iDAEjB,KAAM5L,aAAkB/B,QACvB,MAAM2N,UAAU,kDAEjB,MAAMhK,EAAgBc,4BAA4B0H,KAAKtO,KAAMF,GACvD4T,EAAiB5N,EAAc+L,2BAA2B3N,GAC1DyF,EAAY3J,KAAK0M,WAgBvBtK,OAAOuB,KAAK+P,GAAgB5P,IAAIhE,IAfN,EAACA,EAAW2D,KACrC,MAAMmI,EAAe,GACfhH,EAAiBkB,EAAcc,4BAA4B9G,GAAWyF,eACtElC,EAAauB,EAAevB,WAUlC,OAPAsG,EAAUhH,QAAQT,IACjBuB,EAAQd,QAAQuB,IACXhC,EAAKmB,IAAeuB,EAAegE,oBAAoB1E,IAC1D0H,EAAazH,KAAKjC,OAId0J,GAGiB+H,CAAkB7T,EAAW4T,EAAe5T,IACpD6C,QAAQT,IACvB,MAAMyC,EAAQgF,EAAU/F,QAAQ1B,IACjB,IAAXyC,GACHgF,EAAU5F,OAAOY,EAAO,OAU5B9E,sBAAsByJ,GACrB,MAAMxD,EAAgBD,cAAcwD,oBAAoBC,GACxDtJ,KAAK6L,qBAAqB1H,KACzB2B,GAEDyD,iBAAiBM,gBAAgB/D,EAAe9F,KAAK0M,WAAY1M,KAAK0M,WAAY1M,KAAK0M,WAAY1M,KAAK4J,gBAMzG/J,yBAAyByJ,GACxB,KAAMA,aAA8BzD,eACnC,MAAMiK,UAAU,kDAGjBvG,iBAAiBqK,qBAAqB5T,KAAK0M,WAAY1M,KAAK0M,WAAYpD,EAAoBtJ,MAE5FA,KAAK6L,qBAAqB9H,OAAO/D,KAAK6L,qBAAqBjI,QAAQ0F,GAAqB,GAOzFzJ,iBAAiBgU,EAAc,IAC9B,IAAKpE,cAAcoE,GAClB,MAAM/D,UAAU,8CAEjB,MAAMgE,EAAa,GAsBnB,OArBejE,KAAKkE,UAAU/T,MACvB2C,QAAQqR,IAEd,IADehU,KAAKyM,KAAKuH,GAAOtH,WACpBzI,OAAQ,CACnB,MAAMgQ,EAAsB,GAC5B7R,OAAOuB,KAAKqQ,GAAOrR,QAAQ7C,IAC1B,MACM8E,EADgBgC,4BAA4B0H,KAAKtO,KAAMF,GACxByF,gBAC/BlC,WAAEA,GAAeuB,EACvBqP,EAAoB5Q,GAAcuB,EAAegE,oBAAoBoL,EAAMlU,MAE5E,MAAMmQ,EAAW,IACbjQ,KAAK+P,sBACL8D,KACAI,GAGE/R,EAAOJ,UAAUoS,gBAAgBjE,GACvC6D,EAAW3P,KAAKjC,MAGX4R,EAMRjU,gBACC,OAAOG,KAAK0M,WAAW9B,OAAO1I,GAAQJ,UAAUoO,YAAYhO,IAO7DrC,YAAYqC,GACX,OAAOJ,UAAUoO,YAAYhO,GAO9BrC,cAAciU,GACb,IAAKvG,MAAMiD,QAAQsD,GAClB,MAAMhE,UAAU,0CAEjBgE,EAAWnR,QAAQ,CAACwR,EAAWxP,KAC9B,IAAK3E,KAAKkQ,YAAYiE,GACrB,MAAMrE,iFAAiFnL,OAGzF,GAAGR,KAAKH,MAAMhE,KAAK0M,WAAYoH,GAOhCjU,eAAegU,GAEd,IAAKO,UAAUpU,MAAMiE,OAAQ,CAC5B,MAAM6P,EAAa9T,KAAKqU,iBAAiBR,GACzC7T,KAAKsU,cAAcR,IAOrBjU,YACC,OAAOG,gBAAgB8R,QAOxBjS,iBAAiBiM,GAChB,KAAMA,aAAgB+D,MACrB,MAAMC,UAAU,yCAEjB,MAMMiE,EAAY,CAACQ,EAAGC,KAAM/S,IACpB+S,EAAIT,EAPF,EAACQ,EAAGC,IAAM,GAAG3Q,UAAU0Q,EAAEzQ,IAAI2Q,GAC/BD,EAAE1Q,IAAI0K,GACL,GAAG3K,OAAO4Q,EAAGjG,MAKAkG,CAAEH,EAAGC,MAAO/S,GAAK8S,EAGjCI,EAAkB,GAElBxE,EAAMrE,EAAKD,qBAAqB/H,IAAIgC,GAAiBA,EAAcP,gBAAgBzB,IAAIc,IAC5F+P,EAAgBxQ,KAAKS,EAAe9E,WAC7B8E,EAAenB,UAGjBmR,EAAY,GAElB,IAAIC,EAiBJ,OAhBI1E,EAAIlM,SAEN4Q,EADG1E,EAAIlM,OAAS,EACV8P,EAAU/P,MAAM,KAAMmM,GAEtBA,EAAI,GAAGrM,IAAIgR,GAAK,CAACA,KAEpBnS,QAAQoS,IACX,MAAMC,EAAO,GAKb,OAJAL,EAAgBhS,QAAQ,CAAC7C,EAAW6E,KACnCqQ,EAAKlV,GAAaiV,EAAIpQ,KAEvBiQ,EAAUzQ,KAAK,IAAI4I,MAAMiI,IAClBA,IAIFJ,GAOT,MAAM9C,gBAAgBjC,KACrBhQ,aAAYkS,aAACA,EAAYC,aAAEA,KAAiBiD,IAC3ChT,MAAMgT,GAENjV,KAAK+R,aAAeA,EAEpB/R,KAAKgS,aAAeA,GAQtB,SAASG,aAAa/I,GACrB,OAAOpJ,KAAK6L,qBAAqBN,KAAKjC,GAC9BA,EAAmB6I,iBAAmB/I,GAO/C,SAASxC,4BAA4B9G,GACpC,IAAIoV,EAOJ,GANAlV,KAAK6L,qBAAqBlJ,QAAQmD,IACHA,EAAcc,4BAA4B9G,KAEvEoV,EAAoBpP,EAAcc,4BAA4B9G,OAG3DoV,EACJ,MAAM5E,qCAAqCxQ,KAE5C,OAAOoV,EAMR,SAASxC,oBACR,OAAO1S,KAAK6L,qBAAqB/H,IAAIwF,GAC7BA,EAAmB6L,iBACvB7L,EAAmB6L,mBACnB7L,GAOL,SAASgJ,YAAY7I,EAAQzJ,KAAK0M,WAAY0I,GAAU,GACvD,MAAMjU,EAAOoI,iBAAiB+I,YAAY7I,EAAOiJ,kBAAkBpE,KAAKtO,OAQxE,OAPIoV,GACHjU,EAAKwB,QAAQ,CAACxB,EAAMwD,KACf8E,EAAM9E,aAAkB7C,kBACpBX,EAAKnB,KAAK4J,kBAIbzI,EAOR,SAASiT,UAAUtI,GAClB,MAAMuJ,EAASxF,KAAKkE,UAAUjI,GACxBwJ,EAAc,GAOpB,OANAD,EAAO1S,QAAQqR,IACIlI,EAAKW,KAAKuH,GAAOxB,WACrBvO,OAAS,GACtBqR,EAAYnR,KAAK6P,KAGZsB,EAkBR,SAAS/C,iBAAiB3I,EAAgB2L,GACzC,IAAKA,EAASlU,eAAeuI,GAC5B,MAAM,IAAI1J,eAAe0J"}