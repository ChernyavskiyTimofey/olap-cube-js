class InsufficientRollupData{constructor(e,t){this.message=`Can't add member, member for rollup dimension: ${e} with id: ${t} not found`}}class NotFoundFactId{constructor(e){this.message=`In fact data, no property was found with the name: ${e}`}}class CreateInstanceException{constructor(){this.message="this must have prototype of Cube"}}class DimensionException{constructor(e){this.message=`For the name "${e}" the dimension is already set`}}const handleError=e=>{throw e.message=`[Cube] ${e.message}`,e},originalConsole=console,customConsole={log:e=>{originalConsole.log(`[Cube] ${e}`)},warn:e=>{originalConsole.warn(`[Cube] ${e}`)},warnOnce:(()=>{const e={};return t=>{e[t]||(e[t]=!0,originalConsole.warn(`[Cube] ${t}`))}})()},isSimple=e=>{let t=typeof e;return"object"!==t&&"function"!==t&&"undefined"!==t||null===e};class Fact{constructor(e){try{for(let t in e){if(!e.hasOwnProperty(t))return;isSimple(e[t])?this[t]=e[t]:customConsole.warn(`[Fact] value of prop "${t}" has an unspecified value: ${e[t]}`)}}catch(e){handleError(e)}}}class Cell extends Fact{}function uuidv4(){return"xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g,function(e){let t=16*Math.random()|0;return("x"==e?t:3&t|8).toString(16)})}class EmptyCell extends Cell{constructor(e,t){e.id||(e.id=EmptyCell.generateId()),super(e,t)}static createEmptyCell(e){return new EmptyCell(e)}static isEmptyCell(e){return"string"==typeof e.id}static generateId(){return uuidv4()}}class Member{constructor(e){Object.assign(this,e)}static create(e,t,r,i){if(this!==Member&&!Member.isPrototypeOf(this))throw Error("this.constructor must be prototype of Member");const s={};return s[i]=e,t.forEach(e=>{e!==i&&(s[e]=r[e])}),new this(s)}}const DEFAULT_TEMPLATE_FOREIGN_KEY="%s_id",DEFAULT_FACT_ID_PROP="id",DEFAULT_MEMBER_ID_PROP="id";class InputMember extends Member{static create(e,t,r,i){const s={};return t.forEach(e=>{s[e]=r.hasOwnProperty(e)?r[e]:null}),super.create(e,t,s,i)}}class DimensionTable{constructor({dimension:e,foreignKey:t=DimensionTable.genericId(e),primaryKey:r=DEFAULT_MEMBER_ID_PROP,keyProps:i,otherProps:s=[],members:n=[],defaultMemberOptions:o={}}){if(!e||!i)throw Error('Bad definition DimensionTable, params "dimension" and "keyProps" is required');if(-1!==Object.keys(o).indexOf(r))throw Error('Bad definition DimensionTable, "defaultMemberOptions" must not contain a "primaryKey" property');this.dimension=e,this.foreignKey=t,this.primaryKey=r,this.keyProps=[].concat(i),this.otherProps=[].concat(s),this.members=n.map(e=>new Member(e,this.primaryKey)),this.defaultMemberOptions={...o}}setMemberList(e){[].splice.apply(this.members,[0,this.members.length].concat(e))}clearMemberList(){this.members=[]}getMemberId(e){return e[this.primaryKey]}addMember(e){-1===this.members.indexOf(e)?this.members.push(e):console.log("boo")}createMember(e={},t){const r={...this.defaultMemberOptions,...e},{keyProps:i,otherProps:s,members:n,primaryKey:o}=this,a=i.concat(t).concat(s),l=DimensionTable.reduceId(n,o),c=InputMember.create(l,a,r,o);return this.addMember(c),c}static reduceId(e,t){return e.length?e.reduce((e,r)=>e[t]>r[t]?e:r,0)[t]+1:1}static genericId(e){return DEFAULT_TEMPLATE_FOREIGN_KEY.replace("%s",e)}setMemberId(e,t){e[this.primaryKey]=t}deleteMemberId(e){delete e[this.primaryKey]}removeMember(e){const t=this.members.indexOf(e);if(-1===t)throw new Error("represented member was not found",e);this.members.splice(t,1)}static createDimensionTable(e){return new DimensionTable(e)}}class Tree{getTreeValue(){throw"abstract method"}getParentTree(){throw"abstract method"}getChildTrees(){throw"abstract method"}isExternal(){return!this.getChildTrees().length}isRoot(){return null===this.getParentTree()}getRoot(){let e=this;return this.traceUpOrder(t=>{t.isRoot()&&(e=t)}),e}searchTreeByTreeValue(e){let t=void 0;return this.tracePostOrder((r,i)=>{e(i)&&(t=i)}),t}traceUpOrder(e){!function t(r){const i=r.getParentTree();e(r),null!==i&&t(i)}(this)}tracePostOrder(e){!function t(r){const i=r.getChildTrees(),s=r.getTreeValue();i.length&&i.forEach(e=>{t(e)}),e(s,r)}(this)}tracePreOrder(e){!function t(r){const i=r.getChildTrees(),s=r.getTreeValue();e(s,r),i.length&&i.forEach(e=>{t(e)})}(this)}hasChild(e){let t=!1;return this.tracePreOrder((r,i)=>{i===e&&(t=!0)}),t}hasParent(e){let t=!1;return this.traceUpOrder(r=>{r===e&&(t=!0)}),t}}class DimensionTree extends Tree{constructor(e){super();const{dimensionTable:t,level:r=[],parentNode:i=null}=e;Object.defineProperties(this,{dimensionTable:{value:DimensionTable.createDimensionTable(t),editable:!1,enumerable:!0},parentNode:{value:i,enumerable:!1,editable:!1},level:{value:r.map(e=>new DimensionTree({...e,parentNode:this})),enumerable:!0,editable:!1}}),this.validate()}validate(){const e=[];this.tracePostOrder(t=>{const{dimension:r}=t;if(-1!==e.indexOf(r))throw new DimensionException;e.push(r)})}static createDimensionTree(e){return new DimensionTree(e)}static createProxyDimensionTree(e){const t=e.cloneDimensionTreeWithoutMembers();return e.tracePostOrder(e=>{const{dimension:r,members:i}=e;t.getDimensionTreeByDimension(r).getTreeValue().setMemberList(i)}),t}getTreeValue(){return this.dimensionTable}getParentTree(){return this.parentNode}getChildTrees(){return this.level}getDimensionTreeByDimension(e){return this.getRoot().searchTreeByTreeValue(t=>{return t.getTreeValue().dimension===e})}createProjectionOntoMember(e){const t=this.cloneDimensionTreeWithoutMembers();return this.projectDrillDown(t,e),this.projectDrillUp(t,e),t}projectDrillDown(e,t){let r,i;this.traceUpOrder(s=>{const{dimension:n}=s.getTreeValue(),o=s==this?[t]:i.drillDownDimensionMembers(r);e.getDimensionTreeByDimension(n).getTreeValue().setMemberList(o),r=o,i=s})}projectDrillUp(e,t){let r,i;this.tracePreOrder((s,n)=>{const{dimension:o}=n.getTreeValue(),a=n==this?[t]:i.drillUpDimensionMembers(r);e.getDimensionTreeByDimension(o).getTreeValue().setMemberList(a),r=a,i=n})}cloneDimensionTreeWithoutMembers(){const e=new DimensionTree(this.getRoot());return e.tracePostOrder((e,t)=>{t.getTreeValue().clearMemberList()}),e}removeProjectionOntoMember(e){const t=this.cloneDimensionTreeWithoutMembers();this.projectDrillDown(t,e),this.subtractDimensionTree(t);const r={},{dimension:i,members:s}=t.getRoot().getTreeValue();return r[i]=s,r}subtractDimensionTree(e){const t={};e.tracePostOrder(e=>{const{dimension:r,members:i}=e;t[r]=i}),1===this.getTreeValue().members.length&&this.tracePreOrder((e,r)=>{const{members:i,dimension:s}=e;t[s]=i}),Object.keys(t).forEach(e=>{const r=this.getDimensionTreeByDimension(e).getTreeValue();t[e].forEach(e=>{r.removeMember(e)})})}unionDimensionTree(e){const t={};e.tracePostOrder(e=>{const{dimension:r,members:i}=e;t[r]=i});this.getTreeValue().members;Object.keys(t).forEach(e=>{const r=this.getDimensionTreeByDimension(e).getTreeValue();t[e].forEach(e=>{r.addMember(e)})})}drillDownDimensionMembers(e=this.getTreeValue().members){if(this.isRoot())return e;const t=this.getParentTree(),{members:r,primaryKey:i}=t.getTreeValue(),s=this.getTreeValue(),{foreignKey:n}=s,o=[];return e.forEach(e=>{r.forEach(t=>{t[n]===e[i]&&-1===o.indexOf(t)&&o.push(t)})}),o}drillUpDimensionMembers(e=this.getTreeValue().members){if(this.isExternal())return e;const t=this.getChildTrees()[0].getTreeValue(),{members:r,foreignKey:i}=t,s=[];return e.forEach(e=>{r.forEach(r=>{e[i]===t.getMemberId(r)&&-1===s.indexOf(r)&&s.push(r)})}),s}createMember(e={}){const t=this.getTreeValue(),r=this.getChildTrees().map(e=>e.getTreeValue().foreignKey),i=[];return r.forEach(e=>{i.push(e)}),t.createMember(e,i)}}class DimensionHierarchy{constructor({dimensionTree:e,activeDimension:t,hierarchy:r}){if(!r)throw Error('attribute "hierarchy" must be defined');this.dimensionTree=e instanceof DimensionTree?e:DimensionTree.createDimensionTree(e),this.activeDimension=t||this.dimensionTree.getTreeValue().dimension,this.hierarchy=r}getDimensionTree(){return this.dimensionTree}hasDimension(e){return!!this.dimensionTree.getDimensionTreeByDimension(e)}getActiveDimension(){return this.activeDimension}setActiveDimension(e){this.activeDimension=e}getHierarchy(){return this.hierarchy}static createDimensionHierarchy(e){return new DimensionHierarchy(e)}}class FactTable{constructor({facts:e=[],primaryKey:t=DEFAULT_FACT_ID_PROP}={},r={}){this.primaryKey=t,this.facts=e.map(e=>new Fact(e)),this.defaultFactOptions=r,this.facts.forEach(this.validateFactData.bind(this))}getFacts(){return this.facts}validateFactData(e){if(!e.hasOwnProperty(this.primaryKey))throw new NotFoundFactId(this.primaryKey)}static deleteProps(e,t,r){t.forEach(t=>{t!==r&&delete e[t]})}}class SnowflakeBuilder{static anotherBuild(e,t,r,i,s){r.forEach(r=>{SnowflakeBuilder.anotherBuildOne(r,t,i,e,s)})}static anotherBuildOne(e,t,r,i,s){e.tracePostOrder((e,n)=>{SnowflakeBuilder.processDimension(n,t,r,i,s)})}static processDimension(e,t,r,i,s){const n=e.getTreeValue(),{dimension:o,keyProps:a=[],otherProps:l=[],members:c,foreignKey:m,primaryKey:h}=n,u=e.getChildTrees().map(e=>e.getTreeValue().foreignKey),d=e.getChildTrees().map(e=>e.getTreeValue().dimension);let p;const f=c.length,b=[s,h,m,f,i,t,o,a,l,t,r];if(u.length){let r=[];const i=e.getDimensionTreeByDimension(d[0]).getTreeValue(),s=i.members;r=SnowflakeBuilder.mapFilter(u[0],t,s,i),p=SnowflakeBuilder.makeMemberListLevel.apply(null,b.concat([u,r]))}else p=SnowflakeBuilder.makeMemberList.apply(null,b);t.forEach(e=>{FactTable.deleteProps(e,a,s),FactTable.deleteProps(e,l,s)}),p.forEach(e=>{n.addMember(e)})}static mapFilter(e,t,r,i){const s=[];return r.forEach(r=>{const n=t.filter(t=>t[e]==i.getMemberId(r));s.push(n)}),s}static makeMemberListLevel(e,t,r,i,s,n,o,a,l,c,m,h,u){let d=[],p=0;return u.forEach(n=>{if(n.length){const u=SnowflakeBuilder.makeMemberList(e,t,r,i,s,n,o,a,l,c,m,p);p+=u.length;const f=n[0];h.forEach(e=>{u.forEach(r=>{r[e]=f[e],r[t]=i+d.length+1,d.push(r)}),n.forEach(t=>{delete t[e]})})}}),d}static makeMemberList(e,t,r,i,s,n,o,a=[],l=[],c,m,h=0){const u={},d={},p=[];return m.filter(e=>-1===c.indexOf(e)).forEach(t=>{const r=s.find(r=>r[e]===t[e]),i=SnowflakeBuilder.createKeyFromProps(a,r);i in d||(d[i]=++h)}),n.forEach(e=>{const t=SnowflakeBuilder.createKeyFromProps(a,e);t in u||t in d||(u[t]=++h);const i=u[t];e[r]=i}),Object.keys(u).forEach(e=>{const i=u[e],s=n.find(e=>e[r]===i),o=Member.create(i,[].concat(a).concat(l),s,t);p.push(o)}),p}static createKeyFromProps(e,t){return e.map(e=>t[e]).join(",")}static destroy(e,t,r,i){t.forEach(t=>{const r=e.indexOf(t);-1!==r&&e.splice(r,1)}),t.forEach(e=>{r.forEach(t=>{SnowflakeBuilder.travers([e],t,[SnowflakeBuilder.removeMembers.bind(this,i,t),SnowflakeBuilder.restoreCell])})})}static denormalize(e,t){const r=(new FactTable).getFacts();return e.forEach(e=>{r.push({...e})}),r.forEach(e=>{t.forEach(t=>{SnowflakeBuilder.travers([e],t,[SnowflakeBuilder.restoreCell])})}),r}static restoreCell(e,t,r,i,s,n){const o=new Member(e);n.deleteMemberId(o),delete i[s],Object.assign(i,o)}static removeMembers(e,t,r,i,s,n,o){const a=e.dice({[s]:r}),l=t.getDimensionTreeByDimension(s).getTreeValue();a.getCells().length||l.removeMember(r)}static travers(e,t,r=(()=>{})){e.forEach(e=>{t.tracePreOrder((t,i)=>{((e,t)=>{const i=e.getTreeValue(),{dimension:s,members:n,foreignKey:o}=i,a=t[o],l=n.find(e=>i.getMemberId(e)===a);r.forEach(e=>{e(l,n,s,t,o,i)})})(i,e)})})}static destroyDimensionTree(e,t,r,i){SnowflakeBuilder.travers(e,r,[SnowflakeBuilder.removeMembers.bind(this,i,r),SnowflakeBuilder.restoreCell])}}class Tuple{constructor(e){Object.assign(this,e)}}class Space{static union(){const e={};return[...arguments].forEach(t=>{Space.add(e,t)}),e}static add(e,t){Object.keys(t).forEach(r=>{e[r]||(e[r]=[]),Array.prototype.push.apply(e[r],t[r])})}}class CellTable{constructor({cells:e,primaryKey:t,defaultFactOptions:r={}}){this.cells=e.map(e=>e instanceof Cell?e:EmptyCell.isEmptyCell(e)?new EmptyCell(e):new Cell(e)),this.primaryKey=t,this.defaultFactOptions=r}}class Cube{constructor(e){let{dimensionHierarchies:t=[],cellTable:r={}}=e;Array.isArray(r)&&(r={cells:r},customConsole.warnOnce('first argument "cells" as array type is deprecated now, use object for describe fact table'));const{cells:i=[],primaryKey:s=DEFAULT_FACT_ID_PROP,defaultFactOptions:n={}}=r;this.dimensionHierarchies=t.map(e=>e.hierarchy?e instanceof DimensionHierarchy?e:DimensionHierarchy.createDimensionHierarchy(e):e.dimensionTable?e instanceof DimensionTree?e:DimensionTree.createDimensionTree(e):e instanceof DimensionTable?e:DimensionTable.createDimensionTable(e)),this.cellTable=new CellTable({cells:i,primaryKey:s,defaultFactOptions:{...n}})}static create(e,t=[]){Array.isArray(e)&&(e={facts:e},customConsole.warnOnce('first argument "facts" as array type is deprecated now, use object for describe fact table'));const{facts:r=[],primaryKey:i,defaultFactOptions:s={}}=e;if(!Cube.isPrototypeOf(this)&&Cube!==this)throw new CreateInstanceException;const n=new this({cellTable:{primaryKey:i,defaultFactOptions:s},dimensionHierarchies:t});return n.addFacts(r),n}slice(e,t){return this.dice({[e]:t})}dice(e){const t={};Object.keys(e).forEach(r=>{t[r]=Array.isArray(e[r])?e[r]:[e[r]];const i=findDimensionTreeByDimension.call(this,r);if(!i)return void customConsole.warn(`Not existed dimension: ${r}`);const s=i.getTreeValue();t[r].forEach((e,i)=>{let n=this.getDimensionMembers(r).find(t=>s.getMemberId(t)===s.getMemberId(e));t[r][i]=n,e||customConsole.warn(`Not found member by id ${s.getMemberId(n)}`)})});const r=this.dimensionHierarchies.length;if(Object.keys(t).length>r)throw Error(`Set must have a size not more than ${r} dimensions`);const i=[],s=Object.keys(t).map(e=>{let r;const s=t[e].map(t=>{let i=findDimensionTreeByDimension.call(this,e);const s=i.cloneDimensionTreeWithoutMembers();i.projectDrillDown(s,t),i.projectDrillUp(s,t),r?r.unionDimensionTree(s):r=s;const{dimension:n,members:o}=r.getRoot().getTreeValue();return{[n]:o}});return r&&i.push(r),Space.union(...s)});let n=this.getCells();const o=(e,t)=>{return!Object.keys(t).some(r=>{const i=t[r],{foreignKey:s,primaryKey:n}=findDimensionTreeByDimension.call(this,r).getTreeValue();return!i.find(t=>t[n]===e[s])})};s.forEach(e=>{n=n.filter(t=>o(t,e))});const a=[];return this.dimensionHierarchies.forEach(e=>{let t=!1;if(i.forEach(r=>{e.getTreeValue().dimension===r.getTreeValue().dimension&&(a.push(r),t=!0)}),!t){const{members:t,dimension:r}=e.getTreeValue(),i=DimensionTree.createProxyDimensionTree(e);t.forEach(e=>{let t=!1;if(n.forEach(i=>{o(i,{[r]:[e]})&&(t=!0)}),!t){-1!==i.getTreeValue().members.indexOf(e)&&i.removeProjectionOntoMember(e)}}),a.push(i)}}),new SubCube({cellTable:n,dimensionHierarchies:a,originalCube:this.originalCube||this,previousCube:this})}drillUp(e,t){const r=getHierarchy.call(this,e);return r&&r.hasDimension(t)&&r.setActiveDimension(t),this}drillDown(e,t){const r=getHierarchy.call(this,e);return r&&r.hasDimension(t)&&r.setActiveDimension(t),this}getFacts(){return denormalize.call(this,this.getCells())}addFacts(e){const t=new FactTable({facts:e,primaryKey:this.cellTable.primaryKey}).getFacts().map(e=>new Cell(e));[].push.apply(this.getCells(),t);const r=this.getFacts();return SnowflakeBuilder.anotherBuild(r,t,getDimensionTrees.call(this),this.getCells(),this.cellTable.primaryKey),this}removeFacts(e){const t=this.getCells(),r=this.cellTable.primaryKey,i=e.map(e=>t.find(t=>t[r]===e[r]));this.removeCells(i)}getCells(){return this.cellTable.cells}removeCells(e){SnowflakeBuilder.destroy(this.getCells(),e,this.dimensionHierarchies,this)}getDimensionMembers(e){return findDimensionTreeByDimension.call(this,e).getTreeValue().members}addDimensionMember(e,t={},r={},i={},s){if("string"!=typeof e)throw TypeError(`parameter dimension expects as string: ${e}`);Object.keys(r).forEach(e=>{const t=r[e],i=this.getDimensionMembers(e),s=findDimensionTreeByDimension.call(this,e).getTreeValue(),{primaryKey:n}=s,o=t[n];if(!i.find(e=>o===s.getMemberId(e)))throw new InsufficientRollupData(e,o)});const n=findDimensionTreeByDimension.call(this,e),o=n.getChildTrees(),a=n.getTreeValue(),{foreignKey:l}=a,c={};o.forEach(e=>{const t=e.getTreeValue(),{dimension:i,foreignKey:s,primaryKey:n}=t,o=r[i];if(!o)throw new InsufficientRollupData(i);c[s]=o[n]});const m=Object.assign({},t,c);let h=n.createMember(m),u=l;n.traceUpOrder(e=>{if(n!==e){const{dimension:t,foreignKey:r}=e.getTreeValue(),s={[u]:a.getMemberId(h)};Object.assign(s,i[t]),h=e.createMember(s),u=r}}),this.fillEmptyCells(s)}removeDimensionMember(e,t){const r=findDimensionTreeByDimension.call(this,e),i=r.removeProjectionOntoMember(t),s=this.getCells();Object.keys(i).map(e=>{((e,t)=>{const i=[],n=r.getDimensionTreeByDimension(e).getTreeValue(),o=n.foreignKey;return s.forEach(e=>{t.forEach(t=>{e[o]==n.getMemberId(t)&&i.push(e)})}),i})(e,i[e]).forEach(e=>{const t=s.indexOf(e);-1!==t&&s.splice(t,1)})})}addDimensionHierarchy(e){const t=DimensionTree.createDimensionTree(e);this.dimensionHierarchies.push(t),SnowflakeBuilder.anotherBuildOne(t,this.getCells(),this.getCells(),this.getCells(),this.cellTable.primaryKey)}removeDimensionHierarchy(e){SnowflakeBuilder.destroyDimensionTree(this.getCells(),this.getCells(),e,this),this.dimensionHierarchies.splice(this.dimensionHierarchies.indexOf(e),1)}createEmptyCells(e){const t=[];return Cube.cartesian(this).forEach(r=>{if(!this.dice(r).getCells().length){let i={};Object.keys(r).forEach(e=>{const t=findDimensionTreeByDimension.call(this,e).getTreeValue(),{foreignKey:s}=t;i[s]=t.getMemberId(r[e])});const s={...i,...e},n=EmptyCell.createEmptyCell(s);t.push(n)}}),t}getEmptyCells(){return this.getCells().filter(e=>EmptyCell.isEmptyCell(e))}isEmptyCell(e){return EmptyCell.isEmptyCell(e)}addEmptyCells(e){Cube.validateInstance(e),[].push.apply(this.getCells(),e)}fillEmptyCells(e={}){const t={...this.cellTable.defaultFactOptions,...e};if(!residuals(this).length){const e=this.createEmptyCells(t);this.addEmptyCells(e)}}static validateInstance(e){e.forEach(e=>{if(!(e instanceof EmptyCell))throw new TypeError("some item in list of argument is not instances of EmptyCell")})}isSubCube(){return this instanceof SubCube}static cartesian(e){const t=(e,r,...i)=>r?t(((e,t)=>[].concat(...e.map(e=>t.map(t=>[].concat(e,t)))))(e,r),...i):e,r=[],i=e.dimensionHierarchies.map(e=>e.getTreeValue()).map(e=>(r.push(e.dimension),e.members)),s=[];let n;return i.length&&(n=i.length>1?t.apply(null,i):i[0].map(e=>[e])).forEach(e=>{const t={};return r.forEach((r,i)=>{t[r]=e[i]}),s.push(new Tuple(t)),t}),s}}class SubCube extends Cube{constructor({originalCube:e,previousCube:t,...r}){super(r),this.originalCube=e,this.previousCube=t}}function getHierarchy(e){return this.dimensionHierarchies.find(t=>t.getHierarchy()===e)}function findDimensionTreeByDimension(e){let t;return this.dimensionHierarchies.forEach(r=>{r.getDimensionTreeByDimension(e)&&(t=r.getDimensionTreeByDimension(e))}),t}function getDimensionTrees(){return this.dimensionHierarchies.map(e=>e.getDimensionTree?e.getDimensionTree():e)}function denormalize(e=this.getCells(),t=!0){const r=SnowflakeBuilder.denormalize(e,getDimensionTrees.call(this));return t&&r.forEach((t,r)=>{e[r]instanceof EmptyCell&&delete t[this.cellTable.primaryKey]}),r}function residuals(e){const t=Cube.cartesian(e),r=[];return t.forEach(t=>{e.dice(t).getFacts().length>1&&r.push(t)}),r}export default Cube;
//# sourceMappingURL=cube.esm.min.js.map
