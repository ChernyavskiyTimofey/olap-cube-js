class InsufficientRollupData{constructor(e,t){this.message=`Can't add member, member for rollup dimension: ${e} with id: ${t} not found`}}class NotFoundFactId{constructor(e){this.message=`In fact data, no property was found with the name: ${e}`}}class DimensionException{constructor(e){this.message=`For the name "${e}" the dimension is already set`}}const handleError=e=>{throw e.message=`[Cube] ${e.message}`,e},originalConsole=console,customConsole={log:e=>{originalConsole.log(`[Cube] ${e}`)},warn:e=>{originalConsole.warn(`[Cube] ${e}`)},warnOnce:(()=>{const e={};return t=>{e[t]||(e[t]=!0,originalConsole.warn(`[Cube] ${t}`))}})()},isSimple=e=>{let t=typeof e;return"object"!==t&&"function"!==t&&"undefined"!==t||null===e};class Fact{constructor(e){try{for(let t in e){if(!e.hasOwnProperty(t))return;isSimple(e[t])?this[t]=e[t]:customConsole.warn(`[Fact] value of prop "${t}" has an unspecified value: ${e[t]}`)}}catch(e){handleError(e)}}}class Cell extends Fact{}function uuidv4(){return"xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g,function(e){let t=16*Math.random()|0;return("x"==e?t:3&t|8).toString(16)})}class EmptyCell extends Cell{constructor(e,t){e.id||(e.id=EmptyCell.generateId()),super(e,t)}static createEmptyCell(e){return new EmptyCell(e)}static isEmptyCell(e){return"string"==typeof e.id}static generateId(){return uuidv4()}}class Member{constructor(e){Object.assign(this,e)}static create(e,t,r,i){if(this!==Member&&!Member.isPrototypeOf(this))throw Error("this.constructor must be prototype of Member");const n={};return n[i]=e,t.forEach(e=>{e!==i&&(n[e]=r[e])}),new this(n)}}const DEFAULT_TEMPLATE_FOREIGN_KEY="%s_id",DEFAULT_FACT_ID_PROP="id",DEFAULT_MEMBER_ID_PROP="id";class InputMember extends Member{static create(e,t,r,i){const n={};return t.forEach(e=>{n[e]=r.hasOwnProperty(e)?r[e]:null}),super.create(e,t,n,i)}}class DimensionTable{constructor({dimension:e,foreignKey:t=DimensionTable.genericId(e),primaryKey:r=DEFAULT_MEMBER_ID_PROP,keyProps:i,otherProps:n=[],members:s=[],defaultMemberOptions:o={}}){if(!e||!i)throw Error('Bad definition DimensionTable, params "dimension" and "keyProps" is required');if(-1!==Object.keys(o).indexOf(r))throw Error('Bad definition DimensionTable, "defaultMemberOptions" must not contain a "primaryKey" property');this.dimension=e,this.foreignKey=t,this.primaryKey=r,this.keyProps=[].concat(i),this.otherProps=[].concat(n),this.members=s.map(e=>new Member(e,this.primaryKey)),this.defaultMemberOptions={...o}}setMemberList(e){[].splice.apply(this.members,[0,this.members.length].concat(e))}clearMemberList(){this.members=[]}getMemberPrimaryKey(e){return e[this.primaryKey]}getMemberForeignKey(e){return e[this.foreignKey]}addMember(e){-1===this.members.indexOf(e)?this.members.push(e):console.log("boo")}createMember(e={},t){const r={...this.defaultMemberOptions,...e},{keyProps:i,otherProps:n,members:s,primaryKey:o}=this,a=i.concat(t).concat(n),c=DimensionTable.reduceId(s,o),l=InputMember.create(c,a,r,o);return this.addMember(l),l}static reduceId(e,t){return e.length?e.reduce((e,r)=>e[t]>r[t]?e:r,0)[t]+1:1}static genericId(e){return DEFAULT_TEMPLATE_FOREIGN_KEY.replace("%s",e)}setMemberId(e,t){e[this.primaryKey]=t}deleteMemberId(e){delete e[this.primaryKey]}removeMember(e){const t=this.members.indexOf(e);if(-1===t)throw new Error("represented member was not found",e);this.members.splice(t,1)}static createDimensionTable(e){return new DimensionTable(e)}}class Tree{getTreeValue(){throw"abstract method"}getParentTree(){throw"abstract method"}getChildTrees(){throw"abstract method"}isExternal(){return!this.getChildTrees().length}isRoot(){return null===this.getParentTree()}getRoot(){let e=this;return this.traceUpOrder((t,r)=>{r.isRoot()&&(e=r)}),e}traceUpOrder(e){const t=this.getParentTree();e(this.getTreeValue(),this),null!==t&&t.traceUpOrder(e)}tracePostOrder(e){const t=this.getChildTrees(),r=this.getTreeValue();t.length&&t.forEach(t=>{t.tracePostOrder(e)}),e(r,this)}tracePreOrder(e){const t=this.getChildTrees(),r=this.getTreeValue();e(r,this),t.length&&t.forEach(t=>{t.tracePreOrder(e)})}}class DimensionTree extends Tree{constructor(e){super();const{dimensionTable:t,level:r=[],parentNode:i=null}=e;Object.defineProperties(this,{dimensionTable:{value:DimensionTable.createDimensionTable(t),editable:!1,enumerable:!0},parentNode:{value:i,enumerable:!1,editable:!1},level:{value:r.map(e=>new DimensionTree({...e,parentNode:this})),enumerable:!0,editable:!1}}),this.validateDimensions()}validateDimensions(){const e=[];this.tracePostOrder(t=>{const{dimension:r}=t;if(-1!==e.indexOf(r))throw new DimensionException;e.push(r)})}static createDimensionTree(e){return new DimensionTree(e)}static createProxyDimensionTree(e){const t=e.cloneDimensionTreeWithoutMembers();return e.tracePostOrder(e=>{const{dimension:r,members:i}=e;t.getDimensionTreeByDimension(r).getTreeValue().setMemberList(i)}),t}getTreeValue(){return this.dimensionTable}getParentTree(){return this.parentNode}getChildTrees(){return this.level}getDimensionTreeByDimension(e){const t=this.getRoot();let r=void 0;return t.tracePostOrder((t,i)=>{t.dimension===e&&(r=i)}),r}createProjectionOntoMember(e){const t=this.cloneDimensionTreeWithoutMembers();return this.projectDrillDown(t,e),this.projectDrillUp(t,e),t}projectDrillDown(e,t){this.projectDrill(e,t,"traceUpOrder","drillDownDimensionMembers")}projectDrillUp(e,t){this.projectDrill(e,t,"tracePreOrder","drillUpDimensionMembers")}projectDrill(e,t,r,i){let n,s;this[r]((r,o)=>{const{dimension:a}=r,c=o==this?[t]:s[i](n);e.getDimensionTreeByDimension(a).getTreeValue().setMemberList(c),n=c,s=o})}cloneDimensionTreeWithoutMembers(){const e=new DimensionTree(this.getRoot());return e.tracePostOrder(e=>{e.clearMemberList()}),e}removeProjectionOntoMember(e){const t=this.cloneDimensionTreeWithoutMembers();this.projectDrillDown(t,e),this.subtractDimensionTree(t);const r={},{dimension:i,members:n}=t.getRoot().getTreeValue();return r[i]=n,r}subtractDimensionTree(e){const t={};e.tracePostOrder(e=>{const{dimension:r,members:i}=e;t[r]=i}),1===this.getTreeValue().members.length&&this.tracePreOrder((e,r)=>{const{members:i,dimension:n}=e;t[n]=i}),Object.keys(t).forEach(e=>{const r=this.getDimensionTreeByDimension(e).getTreeValue();t[e].forEach(e=>{r.removeMember(e)})})}unionDimensionTree(e){const t={};e.tracePostOrder(e=>{const{dimension:r,members:i}=e;t[r]=i}),Object.keys(t).forEach(e=>{const r=this.getDimensionTreeByDimension(e).getTreeValue();t[e].forEach(e=>{r.addMember(e)})})}drillDownDimensionMembers(e=this.getTreeValue().members){if(this.isRoot())return e;const t=this.getParentTree().getTreeValue(),r=this.getTreeValue(),{members:i}=t,n=[];return e.forEach(e=>{i.forEach(i=>{r.getMemberForeignKey(i)===t.getMemberPrimaryKey(e)&&-1===n.indexOf(i)&&n.push(i)})}),n}drillUpDimensionMembers(e=this.getTreeValue().members){if(this.isExternal())return e;const t=this.getChildTrees()[0].getTreeValue(),{members:r}=t,i=[];return e.forEach(e=>{r.forEach(r=>{t.getMemberForeignKey(e)===t.getMemberPrimaryKey(r)&&-1===i.indexOf(r)&&i.push(r)})}),i}createMember(e={}){const t=this.getTreeValue(),r=this.getChildTrees().map(e=>e.getTreeValue().foreignKey),i=[];return r.forEach(e=>{i.push(e)}),t.createMember(e,i)}}class DimensionHierarchy{constructor({dimensionTree:e,activeDimension:t,hierarchy:r}){if(!r)throw Error('attribute "hierarchy" must be defined');this.dimensionTree=e instanceof DimensionTree?e:DimensionTree.createDimensionTree(e),this.activeDimension=t||this.dimensionTree.getTreeValue().dimension,this.hierarchy=r}getDimensionTree(){return this.dimensionTree}hasDimension(e){return!!this.dimensionTree.getDimensionTreeByDimension(e)}getActiveDimension(){return this.activeDimension}setActiveDimension(e){this.activeDimension=e}getHierarchy(){return this.hierarchy}static createDimensionHierarchy(e){return new DimensionHierarchy(e)}}class SnowflakeBuilder{static anotherBuild(e,t,r,i,n){r.forEach(r=>{SnowflakeBuilder.anotherBuildOne(r,t,i,e,n)})}static anotherBuildOne(e,t,r,i,n){e.tracePostOrder((e,s)=>{SnowflakeBuilder.processDimension(s,t,r,i,n)})}static processDimension(e,t,r,i,n){const s=e.getTreeValue(),{dimension:o,keyProps:a=[],otherProps:c=[],members:l,foreignKey:m,primaryKey:h}=s,u=e.getChildTrees().map(e=>e.getTreeValue().foreignKey),f=e.getChildTrees().map(e=>e.getTreeValue().dimension);let b;const g=l.length,d=[n,h,m,g,i,t,o,a,c,t,r];if(u.length){let r=[];const i=e.getDimensionTreeByDimension(f[0]).getTreeValue(),n=i.members;r=SnowflakeBuilder.mapFilter(u[0],t,n,i),b=SnowflakeBuilder.makeMemberListLevel.apply(null,d.concat([u,r]))}else b=SnowflakeBuilder.makeMemberList.apply(null,d);function y(e,t,r){t.forEach(t=>{t!==r&&delete e[t]})}t.forEach(e=>{y(e,a,n),y(e,c,n)}),b.forEach(e=>{s.addMember(e)})}static mapFilter(e,t,r,i){const n=[];return r.forEach(r=>{const s=t.filter(t=>t[e]==i.getMemberPrimaryKey(r));n.push(s)}),n}static makeMemberListLevel(e,t,r,i,n,s,o,a,c,l,m,h,u){let f=[],b=0;return u.forEach(s=>{if(s.length){const u=SnowflakeBuilder.makeMemberList(e,t,r,i,n,s,o,a,c,l,m,b);b+=u.length;const g=s[0];h.forEach(e=>{u.forEach(r=>{r[e]=g[e],r[t]=i+f.length+1,f.push(r)}),s.forEach(t=>{delete t[e]})})}}),f}static makeMemberList(e,t,r,i,n,s,o,a=[],c=[],l,m,h=0){const u={},f={},b=[];return m.filter(e=>-1===l.indexOf(e)).forEach(t=>{const r=n.find(r=>r[e]===t[e]),i=SnowflakeBuilder.createKeyFromProps(a,r);i in f||(f[i]=++h)}),s.forEach(e=>{const t=SnowflakeBuilder.createKeyFromProps(a,e);t in u||t in f||(u[t]=++h);const i=u[t];e[r]=i}),Object.keys(u).forEach(e=>{const i=u[e],n=s.find(e=>e[r]===i),o=Member.create(i,[].concat(a).concat(c),n,t);b.push(o)}),b}static createKeyFromProps(e,t){return e.map(e=>t[e]).join(",")}static destroy(e,t,r,i){t.forEach(t=>{const r=e.indexOf(t);-1!==r&&e.splice(r,1)}),t.forEach(e=>{r.forEach(t=>{SnowflakeBuilder.travers([e],t,[SnowflakeBuilder.removeMembers.bind(this,i,t),SnowflakeBuilder.restoreCell])})})}static denormalize(e,t){const r=[];return e.forEach(e=>{r.push({...e})}),r.forEach(e=>{t.forEach(t=>{SnowflakeBuilder.travers([e],t,[SnowflakeBuilder.restoreCell])})}),r}static restoreCell(e,t,r,i,n,s){const o=new Member(e);s.deleteMemberId(o),delete i[n],Object.assign(i,o)}static removeMembers(e,t,r,i,n,s,o){const a=e.dice({[n]:r}),c=t.getDimensionTreeByDimension(n).getTreeValue();a.getCells().length||c.removeMember(r)}static travers(e,t,r=(()=>{})){e.forEach(e=>{t.tracePreOrder((t,i)=>{((e,t)=>{const{dimension:i,members:n,foreignKey:s}=e,o=t[s],a=n.find(t=>e.getMemberPrimaryKey(t)===o);r.forEach(r=>{r(a,n,i,t,s,e)})})(t,e)})})}static destroyDimensionTree(e,t,r,i){SnowflakeBuilder.travers(e,r,[SnowflakeBuilder.removeMembers.bind(this,i,r),SnowflakeBuilder.restoreCell])}}class Tuple{constructor(e){Object.assign(this,e)}}class Space{static union(){const e={};return[...arguments].forEach(t=>{Space.add(e,t)}),e}static add(e,t){Object.keys(t).forEach(r=>{e[r]||(e[r]=[]),Array.prototype.push.apply(e[r],t[r])})}}var freeGlobal="object"==typeof global&&global&&global.Object===Object&&global,freeSelf="object"==typeof self&&self&&self.Object===Object&&self,root=freeGlobal||freeSelf||Function("return this")(),Symbol=root.Symbol,objectProto=Object.prototype,hasOwnProperty=objectProto.hasOwnProperty,nativeObjectToString=objectProto.toString,symToStringTag=Symbol?Symbol.toStringTag:void 0;function getRawTag(e){var t=hasOwnProperty.call(e,symToStringTag),r=e[symToStringTag];try{e[symToStringTag]=void 0}catch(e){}var i=nativeObjectToString.call(e);return t?e[symToStringTag]=r:delete e[symToStringTag],i}var objectProto$1=Object.prototype,nativeObjectToString$1=objectProto$1.toString;function objectToString(e){return nativeObjectToString$1.call(e)}var nullTag="[object Null]",undefinedTag="[object Undefined]",symToStringTag$1=Symbol?Symbol.toStringTag:void 0;function baseGetTag(e){return null==e?void 0===e?undefinedTag:nullTag:symToStringTag$1&&symToStringTag$1 in Object(e)?getRawTag(e):objectToString(e)}function overArg(e,t){return function(r){return e(t(r))}}var getPrototype=overArg(Object.getPrototypeOf,Object);function isObjectLike(e){return null!=e&&"object"==typeof e}var objectTag="[object Object]",funcProto=Function.prototype,objectProto$2=Object.prototype,funcToString=funcProto.toString,hasOwnProperty$1=objectProto$2.hasOwnProperty,objectCtorString=funcToString.call(Object);function isPlainObject(e){if(!isObjectLike(e)||baseGetTag(e)!=objectTag)return!1;var t=getPrototype(e);if(null===t)return!0;var r=hasOwnProperty$1.call(t,"constructor")&&t.constructor;return"function"==typeof r&&r instanceof r&&funcToString.call(r)==objectCtorString}class Cube{constructor(e={}){if(!(isPlainObject(e)||e instanceof Cube))throw TypeError("The argument must be plain object or instance of Cube");let{dimensionHierarchies:t=[],cellTable:r=[],defaultFactOptions:i={},factPrimaryKey:n=DEFAULT_FACT_ID_PROP}=e;this.defaultFactOptions=i,this.factPrimaryKey=n,this.dimensionHierarchies=t.map(e=>e.hierarchy?e instanceof DimensionHierarchy?e:DimensionHierarchy.createDimensionHierarchy(e):e.dimensionTable?e instanceof DimensionTree?e:DimensionTree.createDimensionTree(e):e instanceof DimensionTable?e:DimensionTable.createDimensionTable(e)),this.cellTable=r.map(e=>e instanceof Cell?e:EmptyCell.isEmptyCell(e)?new EmptyCell(e):new Cell(e))}slice(e,t){return this.dice({[e]:t})}dice(e){if(!(isPlainObject(e)||e instanceof Tuple))throw TypeError("The argument must be a plain object");const t=(e,t)=>{const r=getDimensionTreeByDimension.call(this,t).getTreeValue(),i=r.members;return e.forEach((t,n)=>{let s=i.find(e=>r.getMemberPrimaryKey(e)===r.getMemberPrimaryKey(t));if(!s)throw RangeError(`Not found member by id ${r.getMemberPrimaryKey(s)}`);e instanceof Member||(e[n]=s)}),e},r={};Object.keys(e).forEach(i=>{let n=e[i];n=(e=>Array.isArray(e)?e:[e])(n),n=t(n,i),r[i]=n});const i=Object.keys(r),n=this.dimensionHierarchies.length;if(i.length>n)throw Error(`Set must have a size not more than ${n} dimensions`);const s=[],o=i.map(e=>{let t;const i=r[e].map(r=>{let i=getDimensionTreeByDimension.call(this,e);const n=i.cloneDimensionTreeWithoutMembers();i.projectDrillDown(n,r),i.projectDrillUp(n,r),t?t.unionDimensionTree(n):t=n;const{dimension:s,members:o}=t.getRoot().getTreeValue();return{[s]:o}});return t&&s.push(t),Space.union(...i)});let a=this.getCells();const c=(e,t)=>{return!Object.keys(t).some(r=>{const i=t[r],{foreignKey:n,primaryKey:s}=getDimensionTreeByDimension.call(this,r).getTreeValue();return!i.find(t=>t[s]===e[n])})};o.forEach(e=>{a=a.filter(t=>c(t,e))});const l=[];return this.dimensionHierarchies.forEach(e=>{let t=!1;if(s.forEach(r=>{e.getTreeValue().dimension===r.getTreeValue().dimension&&(l.push(r),t=!0)}),!t){const{members:t,dimension:r}=e.getTreeValue(),i=DimensionTree.createProxyDimensionTree(e);t.forEach(e=>{let t=!1;if(a.forEach(i=>{c(i,{[r]:[e]})&&(t=!0)}),!t){-1!==i.getTreeValue().members.indexOf(e)&&i.removeProjectionOntoMember(e)}}),l.push(i)}}),new SubCube({cellTable:a,dimensionHierarchies:l,originalCube:this.originalCube||this,previousCube:this})}drillUp(e,t){const r=getHierarchy.call(this,e);return r&&r.hasDimension(t)&&r.setActiveDimension(t),this}drillDown(e,t){const r=getHierarchy.call(this,e);return r&&r.hasDimension(t)&&r.setActiveDimension(t),this}getFacts(){return denormalize.call(this,this.getCells())}addFacts(e){if(!Array.isArray(e))throw TypeError("The argument must be instance of Array");e.forEach(validateFactData.bind(null,this.factPrimaryKey));const t=e.map(e=>new Cell(e));[].push.apply(this.getCells(),t);const r=this.getFacts();return SnowflakeBuilder.anotherBuild(r,t,getDimensionTrees.call(this),this.getCells(),this.factPrimaryKey),this}removeFacts(e){if(!Array.isArray(e))throw TypeError("The argument must be instance of Array");const t=this.getCells(),r=this.factPrimaryKey,i=e.map(e=>t.find(t=>t[r]===e[r]));this.removeCells(i)}getCells(){return this.cellTable}removeCells(e){if(!Array.isArray(e))throw TypeError("The argument must be instance of Array");e.forEach(e=>{if(!(e instanceof Cell))throw TypeError("The list of cells must contain only instances of Cell and EmptyCell")}),SnowflakeBuilder.destroy(this.getCells(),e,this.dimensionHierarchies,this)}getDimensionMembers(e){if("string"!=typeof e)throw TypeError("The first argument must be string");return getDimensionTreeByDimension.call(this,e).getTreeValue().members}addDimensionMember(e,t={},r={},i={},n={}){if("string"!=typeof e)throw TypeError("The first argument must be instance of string");if(!(isPlainObject(t)&&isPlainObject(r)&&isPlainObject(i)&&isPlainObject(n)))throw TypeError("The arguments after the first must be plain objects");Object.keys(r).forEach(e=>{const t=r[e],i=this.getDimensionMembers(e),n=getDimensionTreeByDimension.call(this,e).getTreeValue(),{primaryKey:s}=n,o=t[s];if(!i.find(e=>o===n.getMemberPrimaryKey(e)))throw new InsufficientRollupData(e,o)});const s=getDimensionTreeByDimension.call(this,e),o=s.getChildTrees(),a=s.getTreeValue(),{foreignKey:c}=a,l={};o.forEach(e=>{const t=e.getTreeValue(),{dimension:i,foreignKey:n,primaryKey:s}=t,o=r[i];if(!o)throw new InsufficientRollupData(i);l[n]=o[s]});const m=Object.assign({},t,l);let h=s.createMember(m),u=c;s.traceUpOrder((e,t)=>{if(s!==t){const{dimension:r,foreignKey:n}=e,s={[u]:a.getMemberPrimaryKey(h)};Object.assign(s,i[r]),h=t.createMember(s),u=n}}),this.fillEmptyCells(n)}removeDimensionMember(e,t){if("string"!=typeof e)throw TypeError("The first argument must be instance of string");if(!(t instanceof Member))throw TypeError("The second argument must be instance of Member");const r=getDimensionTreeByDimension.call(this,e),i=r.removeProjectionOntoMember(t),n=this.getCells();Object.keys(i).map(e=>{((e,t)=>{const i=[],s=r.getDimensionTreeByDimension(e).getTreeValue(),o=s.foreignKey;return n.forEach(e=>{t.forEach(t=>{e[o]==s.getMemberPrimaryKey(t)&&i.push(e)})}),i})(e,i[e]).forEach(e=>{const t=n.indexOf(e);-1!==t&&n.splice(t,1)})})}addDimensionHierarchy(e){const t=DimensionTree.createDimensionTree(e);this.dimensionHierarchies.push(t),SnowflakeBuilder.anotherBuildOne(t,this.getCells(),this.getCells(),this.getCells(),this.factPrimaryKey)}removeDimensionHierarchy(e){if(!(e instanceof DimensionTree))throw TypeError("The argument must be instance of DimensionTree");SnowflakeBuilder.destroyDimensionTree(this.getCells(),this.getCells(),e,this),this.dimensionHierarchies.splice(this.dimensionHierarchies.indexOf(e),1)}createEmptyCells(e={}){if(!isPlainObject(e))throw TypeError("Cell option argument must be a pure object");const t=[];return Cube.cartesian(this).forEach(r=>{if(!this.dice(r).getCells().length){const i={};Object.keys(r).forEach(e=>{const t=getDimensionTreeByDimension.call(this,e).getTreeValue(),{foreignKey:n}=t;i[n]=t.getMemberPrimaryKey(r[e])});const n={...this.defaultFactOptions,...e,...i},s=EmptyCell.createEmptyCell(n);t.push(s)}}),t}getEmptyCells(){return this.getCells().filter(e=>EmptyCell.isEmptyCell(e))}isEmptyCell(e){return EmptyCell.isEmptyCell(e)}addEmptyCells(e){if(!Array.isArray(e))throw TypeError("The argument must be instance of Array");e.forEach((e,t)=>{if(!this.isEmptyCell(e))throw TypeError(`Some item in list of argument is not instances of EmptyCell, index: ${t}`)}),[].push.apply(this.getCells(),e)}fillEmptyCells(e){if(!residuals(this).length){const t=this.createEmptyCells(e);this.addEmptyCells(t)}}isSubCube(){return this instanceof SubCube}static cartesian(e){if(!(e instanceof Cube))throw TypeError("The argument must be instance of Cube");const t=(e,r,...i)=>r?t(((e,t)=>[].concat(...e.map(e=>t.map(t=>[].concat(e,t)))))(e,r),...i):e,r=[],i=e.dimensionHierarchies.map(e=>e.getTreeValue()).map(e=>(r.push(e.dimension),e.members)),n=[];let s;return i.length&&(s=i.length>1?t.apply(null,i):i[0].map(e=>[e])).forEach(e=>{const t={};return r.forEach((r,i)=>{t[r]=e[i]}),n.push(new Tuple(t)),t}),n}}class SubCube extends Cube{constructor({originalCube:e,previousCube:t,...r}){super(r),this.originalCube=e,this.previousCube=t}}function getHierarchy(e){return this.dimensionHierarchies.find(t=>t.getHierarchy()===e)}function getDimensionTreeByDimension(e){let t;if(this.dimensionHierarchies.forEach(r=>{r.getDimensionTreeByDimension(e)&&(t=r.getDimensionTreeByDimension(e))}),!t)throw RangeError(`Not existed dimension: ${e}`);return t}function getDimensionTrees(){return this.dimensionHierarchies.map(e=>e.getDimensionTree?e.getDimensionTree():e)}function denormalize(e=this.getCells(),t=!0){const r=SnowflakeBuilder.denormalize(e,getDimensionTrees.call(this));return t&&r.forEach((t,r)=>{e[r]instanceof EmptyCell&&delete t[this.factPrimaryKey]}),r}function residuals(e){const t=Cube.cartesian(e),r=[];return t.forEach(t=>{e.dice(t).getFacts().length>1&&r.push(t)}),r}function validateFactData(e,t){if(!t.hasOwnProperty(e))throw new NotFoundFactId(e)}export default Cube;
//# sourceMappingURL=cube.esm.min.js.map
